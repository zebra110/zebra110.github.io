[{"title":"关于异步","date":"2017-03-16T08:00:10.898Z","path":"2017/03/16/关于异步/","text":"异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 阻塞 / 非阻塞描述的是函数，指访问某个函数时是否会阻塞线程(block，线程进入阻塞状态)。 同步 / 异步描述的是执行IO操作的主体是谁，同步是由用户进程自己去执行最终的IO操作。异步是用户进程自己不关系实际IO操作的过程，只需要由内核在IO完成后通知它既可，由内核进程来执行最终的IO操作。","tags":[{"name":"Node.Js","slug":"Node-Js","permalink":"http://yoursite.com/tags/Node-Js/"}]},{"title":"CSS3（一）","date":"2017-03-16T07:59:16.446Z","path":"2017/03/16/CSS3（一）/","text":"css标准流display:inline-block 在CSS中，块级对象元素会单独占一行显示，多个block元素会各自新起一行，并且可以设置width,height属性；而内联对象元素前后不会产生换行，一系列inline元素都在一行内显示，直到该行排满，对inline元素设置width,height属性无效。我们有个时候既希望元素具有宽度高度特性，又具有同行特性，这个时候我们可以使用inline-block。在CSS中通过display:inline-block对一个对象指定inline-block属性，简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 不兼容——在IE下实现display:inline-block效果的两种方法：1、先用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（原理：这是IE的一个经典bug，如果先定义了display:inline-block，然后再设置display回inline或block，layout不会消失）（暂时理解为布局不会混乱），代码如下：div {display:inline-block;}div {display:inline;} 2、直接让块元素设置为内联对象(display:inline)，然后通过zoom:1触发块元素的layout，代码如下：div {display:inline; zoom:1;} 子绝父相的定位（常用）&lt;style&gt; div {font-size: 15px;color: #fff;} .test1{width: 400px;height: 400px;background: #234;position:relative;} .test2 {width: 300px;height: 300px;background: #345; position: absolute; left: 40px;top: 40px; } .test{ width: 500px;height: 500px;background: #123; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;test1&quot;&gt; test1 &lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;test&quot;&gt; test &lt;/div&gt; &lt;/body&gt; 记一个学习浮动的漏洞对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。 inline-block和float的区别虽然设置浮动跟设置inline-block有些特征类似，但两者的区别还是非常明显的: 文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。 水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。 垂直对齐（Vertical alignment）：inline-block元素沿着默认的基线对齐。浮动元素紧贴顶部。你可以通过vertical属性设置这个默认基线，但对浮动元素这种方法就不行了。这也是我倾向于inline-block的主要原因。 空白（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空白。而浮动元素会忽略空白节点，互相紧贴 IE6和IE7：Ie67对此属性部分支持。如果你要兼容这些浏览器，必须解决这个问题。这不是个大问题，但值得留意一下。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML5新特性","date":"2017-03-16T07:58:31.887Z","path":"2017/03/16/HTML5新特性/","text":"2017-02-12 22:41:11 星期二 1. 新的Doctype尽管使用&lt;!DOCTYPE html&gt;，即使浏览器不懂这句话也会按照标准模式去渲染 2. Figure元素用和来语义化地表示带标题的图片 &lt;figure&gt; &lt;img src=”path/to/image” alt=”About image” /&gt; &lt;figcaption&gt; &lt;p&gt;This is an image of something interesting. &lt;/p&gt; &lt;/figcaption&gt; &lt;/figure&gt; 3. 重新定义的已经被重新定义了，现在被用来表示小的排版，如网站底部的版权声明 4. 去掉link和script标签里面的type属性5. 加/不加 括号HTML5没有严格的要求属性必须加引号，闭合不闭合，但是建议加上引号和闭合标签 6. 让你的内容可编辑，只需要加一个contenteditable属性7. Email Inputs如果我们给Input的type设置为email，浏览器就会验证这个输入是否是email类型，当然不能只依赖前端的校验，后端也得有相应的校验 8. Placeholders这个input属性的意义就是不必通过javascript来做placeholder的效果了 9. Local Storage使用Local Storage可以永久存储大的数据片段在客户端（除非主动删除），目前大部分浏览器已经支持，在使用之前可以检测一下window.localStorage是否存在 10. 语义化的header和footer11. 更多的HTML5表单特性12. IE和HTML5默认的，HTML5新元素被以inline的方式渲染，不过可以通过下面这种方式让 其以block方式渲染 header, footer, article, section, nav, menu, hgroup {display: block;}不幸的是IE会忽略这些样式，可以像下面这样fix: document.createElement(”article”);document.createElement(”footer”);document.createElement(”header”);document.createElement(”hgroup”);document.createElement(”nav”);document.createElement(”menu”); 13. hgroup一般在header里面用来将一组标题组合在一起，如 &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt; Recall Fan Page &lt;/h1&gt; &lt;h2&gt; Only for people who want the memory of a lifetime. &lt;/h2&gt; &lt;/hgroup&gt; &lt;/header&gt; 14. Required属性required属性定义了一个input是否是必须的，你可以像下面这样声明 或者 15. Autofocus属性正如它的词义，就是聚焦到输入框里面 16. Audio支持HTML5提供了标签，你不需要再按照第三方插件来渲染音频，大多数现代浏览器提供了对于HTML5 Audio的支持，不过目前仍旧需要提供一些兼容处理，如 &lt;audio autoplay=”autoplay” controls=”controls”&gt; &lt;source src=”file.ogg” /&gt;&lt;!–FF–&gt; &lt;source src=”file.mp3″ /&gt;&lt;!–Webkit–&gt; &lt;a href=”file.mp3″&gt;Download this file.&lt;/a&gt; &lt;/audio&gt; 17. Video支持和Audio很像，标签提供了对于video的支持，由于HTML5文档并没有给video指定一个特定的编码，所以浏 览器去决定要支持哪些编码，导致了很多不一致。Safari和IE支持H.264编码的格式，Firefox和Opera支持Theora和Vorbis 编码的格式，当使用HTML5 video的时候，你必须都提供： &lt;video controls preload&gt; &lt;source src=”cohagenPhoneCall.ogv” type=”video/ogg; codecs=’vorbis, theora’” /&gt; &lt;source src=”cohagenPhoneCall.mp4″ type=”video/mp4; ’codecs=’avc1.42E01E, mp4a.40.2′” /&gt; &lt;p&gt; Your browser is old. &lt;a href=”cohagenPhoneCall.mp4″&gt;Download this video instead.&lt;/a&gt; &lt;/p&gt; &lt;/video&gt; 18. 预加载视频preload属性就像它的字面意思那么简单，你需要决定是否需要在页面加载的时候去预加载视频 19. 显示视频控制 20. 正则表达式由于pattern属性，我们可以在你的markup里面直接使用正则表达式了 &lt;form action=“” method=”post”&gt; &lt;label for=”username”&gt;Create a Username: &lt;/label&gt; &lt;input type=”text” name=”username” id=”username” placeholder=”4 &lt;&gt; 10 “pattern=”[A-Za-z]{4,10}” autofocus required&gt; &lt;button type=”submit”&gt;Go &lt;/button&gt; &lt;/form&gt; 21. 检测属性支持除了Modernizr之外我们还可以通过javascript简单地检测一些属性是否支持，如： if (!’pattern’ in document.createElement(’input’) ) {// do client/server side validation} 22. Mark元素把元素看做是高亮的作用，当我选择一段文字的时候，javascript对于HTML的markup效果应该是这样的： Search Results They were interrupted, just after Quato said, ”Open your Mind”. 23. 什么时候用HTML5已经引入了这么多元素，那么div我们还要用吗？div你可以在没有更好的元素的时候去用。 24. Data属性&lt;div id=”myDiv” data-custom-attr=”My Value”&gt; Bla Bla &lt;/div&gt; &lt;style&gt; h1:hover:after { content: attr(data-hover-response); color: black; position: absolute; left: 0; } &lt;/style&gt; &lt;h1 data-hover-response=”I Said Don’t Touch Me!”&gt; Don’t Touch Me &lt;/h1&gt; 27. Output元素元素用来显示计算结果，也有一个和label一样的for属性 28. 用Range Input来创建滑块HTML5引用的range类型可以创建滑块，它接受min, max, step和value属性可以使用css的:before和:after来显示min和max的值 &lt;input type=”range” name=”range” min=”0″ max=”10″ step=”1″ value=”&quot;&gt; input[type=range]:before { content: attr(min); padding-right: 5px; } input[type=range]:after { content: attr(max); padding-left: 5px;}","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"JS面向对象","date":"2017-03-16T07:57:11.770Z","path":"2017/03/16/JS面向对象/","text":"2030-01-26 23:33:13 星期六 基本概念ECMA关于对象的定义是：”无序属性的集合，其属性可以包含基本值、对象或者函数。“对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 类在现实生活中，相似的对象之间往往都有一些共同的组成特征。类，实际上是对象的设计蓝图或者制作配方。我们能基于相同的类创建出许多不同的对象，这些对象又会含有各自的属性和方法。 封装封装主要用于阐述对象中所包含（或封装的内容），它通常由两部分组成： 相关的数据（用于存储属性）基于这些数据所能做的事（所能调用的方法） 聚合聚合是指我们将现有对象合并成一个新对象的过程。例如：Book是由一个或多个author对象，publisher对象、若干chapter对象等组合而成的对象。 继承通过继承这种方式，我们可以非常优雅地实现对现有代码的重用。例如：我们定义了一个Person对象，他包含了wolk()，sleep(),speak(),eat()等方法，也包含了age,height,weight等属性，这时当我们再定义一个coder对象的时候，你不必将上述的属性和方法都重写一遍，你只需继承他即可，然后你只需将coder这个对象属于他自己的那部分特殊功能写出来。 多态上述实例中，我们的coder对象继承了person对象的一些属性和方法，这意味着这两个对象都实现了”speak”等方法，现在，我们的代码中有一个叫做James的变量，即便是我们不知道它是一个person对象还是一个coder对象的情况下，也依然可以直接调用该对象的”speak”方法。类似这种不同对象通过相同的方法调用实现各自行为的能力，我们就称之为“多态” 创建对象我们可以通过对象直接量、new关键字和object.create()函数来创建。 对象直接量创建对象最简单的方法就是在js中使用对象直接量，它是由若干名/值对组成的映射表，名/值对中间用冒号分隔，多个名/值对用逗号分隔。整个映射表用花括号（{}）括起来。 var empty = {};//没有任何属性的对象 var fruits = {apple:big , orange:yellow}; var company = { CEO : &quot;Tim Cook&quot;,//属性名字里有空格，必须用字符串表示 Designer:&quot;Ive&quot;; &quot;for&quot;:&quot;all audiences&quot;,//&quot;for&quot;是保留字，必须用引号 employees:{ firstname:&quot;David&quot;, //这里的属性名都没有引号 lastname:&quot;fill&quot; //这个属性的值是一个对象 } }; 对象里还可以嵌套对象（company里嵌套了employees对象） new关键字创建对象 关键字new后面跟随一个函数调用，这个函数称为构造函数（constructor），javascript语言核心的原始类型都包含内置的构造函数。 &lt;script type=&quot;text/javascript&quot;&gt; var obj = new Object();//创建一个空对象，和{}一样 var arr = new Array();//创建一个空数组，和[]一样 &lt;/script&gt; js原型-&gt;参照：javascript学习总结（五）原型和原型链详解 工厂模式由于ECMAScript中无法创建类，因此，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节： &lt;script type=&quot;text/javascript&quot;&gt; var Car = (function(){ var Car = function(model,year,miles){ this.model = model; this.year = year; this.miles = miles; }; return function(model,year,miles){ return new Car(model,year,miles); } })(); var Benz = new Car(&quot;Benz&quot;,2014,1000); var Audi = new Car(&quot;Audi&quot;,2013,800); &lt;/script&gt; 什么时候使用工厂模式? 以下几种情景下工厂模式特别有用： 对象的构建十分复杂需要依赖具体环境创建不同实例处理大量具有相同属性的小对象元素、属性和方法说到数组，我们常说其中包含的是元素，而当说到对象的时候，我们常会说其中包含的是属性。另外，对象的属性也可以是一个函数，因为函数本身也是一种数据，在这种情况下，我们会称该属性为方法： &lt;script type=&quot;text/javascript&quot;&gt; var wolf = { name :wolffy； run:function(){ alert(&quot;￼wolf,wolf!&quot;); } } &lt;/script&gt; 调用对象方法 var parrot = { name : “bage”, hair : “brown”, say : function(){ alert( ‘I am ‘ + parrot.name); } } parrot.say(); 注： 尽量使用点号表示法来访问对象的属性和方法。 不要在对象中使用带引号的属性标示。构造器函数另外，我们还可以使用构造器函数的方式来创建对象。看下面一个例子： function Person(name,age,occupation){ this.name = name; this.age = age; this.occupation = occupation; this.sayName = function(){ alert(this.name); } } var person1 = new Person(&quot;trigkit4&quot;,21,&quot;student&quot;); var person2 = new Person(&quot;Jack&quot;,25,&quot;Engineer&quot;); 优点 使用构造器函数的好处在于，它可以在创建对象时接收一些参数。按照惯例，构造函数的函数名应始终以一个大写字母开头，以区分普通函数。 区别 构造函数与普通函数的区别在于调用的方式不同，任何函数，只要通过new操作符来调用，那它就可以作为构造函数。 缺点 使用构造函数的主要问题是，每个方法都要在每个实例上重新创建一遍。 扩展阅读：javascript学习总结（五）原型和原型链详解 全局对象事实上，程序所在的宿主环境一般都会为其提供一个全局对象，而所谓的全局变量其实都只不过是该对象的属性罢了。 例如，当程序所在的宿主环境是web浏览器时，它所提供的全局对象就是window了。 内建对象内建对象大致分为三组： 数据封装类对象——包括Object、Array、Boolean、Number和String。这些对象代表着javascript中不同的数据类型，并且都拥有各自不同的typeof返回值，以及undefined和null状态工具类对象——包括Math、Date、RegExp等用于提供遍历的对象错误类对象——包括一般性错误对象及其它各种更特殊的错误类对象Object是js中所有对象的父级对象，这意味着我们创建的所有对象都继承于此。 所谓的空对象实际上并不是完全无用的，它还是包含了一些属性和方法的： 返回构造器函数的构造器属性返回对象描述字符串的toString()方法返回对象单值描述信息的valueOf()方法例如： var o = new Object();o.toString();//[object Object]ArrayArray()是一个用来构建数组的内建构造器函数。数组主要由如下三种创建方式： array = new Array()array = new Array([size])array = new Array(element0, element1, …, elementN)Array 对象方法方法 描述 concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。valueOf() 返回数组对象的原始值concat()方法：合并数组 [1,2]concat([3,4],[5,6]);//[1,2,3,4,5,6]join()方法： &lt;script type=&quot;text/javascript&quot;&gt; var a = [1,2,3]; a.join(&quot;&quot;);// =&gt;&quot;123&quot; &lt;/script&gt; //pop()方法：移除数组最后一个元素，并将其返回 &lt;script type=&quot;text/javascript&quot;&gt; var fruits = [&apos;apple&apos;,&apos;banana&apos;,&apos;pineapple&apos;]; fruits.pop();// pineapple console.log(fruits);//[&quot;apple&quot;,&quot;banana&quot;] &lt;/script&gt; //shift()方法：删除并返回数组的第一个元素。 &lt;script type=&quot;text/javascript&quot;&gt; var a = [1,2,3]; a.shift();//1 console.log(a);//[2,3] &lt;/script&gt; //slice(start,end)方法：截取数组的某一部分，不会对原数组进行任何修改 &lt;script type=&quot;text/javascript&quot;&gt; var num = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]; console.log(num.slice(1,4));//[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;] console.log(num);//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;] &lt;/script&gt; //splice(start,delete_count,i1,i2…)方法：删除数组元素的同时添加新的元素。i1,i2为要插入的新元素 &lt;script type=&quot;text/javascript&quot;&gt; var arr = [&apos;js&apos;,&apos;css&apos;,&apos;html&apos;,&apos;php&apos;,&apos;c&apos;]; arr.splice(1, 2,&apos;python&apos;,&apos;jquery&apos;);//[&quot;css&quot;,&quot;html&quot;]","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jquery（三）","date":"2017-03-16T07:56:29.937Z","path":"2017/03/16/jquery（三）/","text":"8、类数组的操作jQuery选择器返回的是一个jQuery对象(该对象可能包括了多个dom节点),如果要对这些dom节点分别做不同的处理，就需要去遍历，需要调用jQuery对象提供的一些方法或者属性，称之为类数组的操作。类数组就是DOM节点数组 1)each(fn(i)):循环遍历每一个元素,this代表被迭代的dom对象，$(this)代表被迭代的jQuery对象。（i根据实际情况选择要还是不要）。 2)eq(index)：返回index+1位置处的jQuery对象 3)index(obj)：返回下标，其中obj可以是dom对象或者jQuery对象。 4)length属性：dom对象的个数 5)get()：返回dom对象组成的数组 6)get(index)：返回index+1个dom对象。 $(&apos;#b4&apos;).click(function(){ $(&apos;#s2 option&apos;).each(function(){ $(&apos;#s1&apos;).append($(this)); }); }); $(function(){ $(&apos;#b1&apos;).click(function(){ var $obj = $(&apos;ul li&apos;); $obj.each(function(i){ //i:表示正在被访问的那个节点的下标, //下标从0开始 if(i == 0){ $(this).css(&apos;font-size&apos;,&apos;50px&apos;); }else if(i==1){ $(this).css(&apos;font-style&apos;,&apos;italic&apos;); }else{ $(this).css(&apos;color&apos;,&apos;red&apos;).css(&apos;font-size&apos;,&apos;80px&apos;); } }); }); 9、jQuery对ajax编程的支持(1)load方法: 作用：是将服务器返回的数据直接添加到符合要求的节点之上，相当于obj.innerHTML = 返回的数据。 语法:$obj.load(请求地址,[请求参数]); 其中，请求参数可以有两种形式: 第一种：请求字符串，比如 “username=zs”,或者“username=zs&amp;age=22”。 第二种：javascript对象，比如 {‘username’:’zs’}，或者{‘username’:’zs’,’age’:22} load方法如果没有请求参数，会发送get请求，如果有请求参数，会发送post请求。 (2)$.get方法 作用：向服务器发送get请求 语法:$.get(url,[data],[callback],[type]): url:请求地址 data:请求参数,可以是请求字符串或者是js对象。格式为：{key,value} eg:{“name”:$(“#cost_name”).val()} callback: 是一个回调函数，用于处理服务器返回的数据，其格式 function(data,statusText), data是服务器返回的数据，如果服务器返回的是json字符串，$.get方法会自动将其转换成一个js对象或者js对象组成的数组。statusText是服务器处理的状态。 type:服务器返回的数据类型: text : 文本字符串 html : html内容 xml: 返回dom兼容的xml对象 json: json字符串 script: javascript脚本 function quoto(){ $(&apos;#tb1&apos;).empty(); $.get(&apos;quoto.do?&apos; + Math.random(),function(data){ //data:服务器返回的数据, 如果服务器 //返回的是json字符串，$.get方法会自动 //将其转换成一个js对象或者js对象组成的数组。 for(i=0;i&lt;data.length;i++){ $(&apos;#tb1&apos;).append( &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[i].code +&apos;&lt;/td&gt;&lt;td&gt; &apos;+ data[i].name + &apos;&lt;/td&gt;&lt;td&gt; &apos; + data[i].price + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;); } },&apos;json&apos;); } $.post()格式同上。 $.put(url,[data],[callback],[type]): //焦点离开资费名输入框进行ajax检测 $(function(){ $(&quot;#name&quot;).blur(function(){ var name = $(this).val(); //发送ajax请求 $.post( &quot;validFeeName.action&quot;,//请求url {&quot;name&quot;:name},//提交参数 function(data){//data是服务器返回的ok值 if(data){//如果返回true $(&quot;#name_error&quot;).removeClass(&quot;error_msg&quot;) .html(&quot;资费名称可用&quot;); }else{//如果返回false $(&quot;#name_error&quot;).addClass(&quot;error_msg&quot;) .html(&quot;资费名称重复&quot;); } } ,&quot;text&quot;); }); }); (3)$.ajax方法 作用：可以设置不同的参数，控制ajax对象向服务器发请求。 语法:$.ajax(options): 其中，options是一个形如 key1:value1,key2,value2…}的js对象，用于指定发送请求的选项。 选项参数如下： url(string):请求地址 type(string):GET/POST data(object/string):请求参数，可以是请求字符串或者js对象 dataType(string) :服务器返回的数据类型 success(function):请求成功后调用的回调函数，有两个参数： function(data,textStatus),其中， data是服务器返回的数据， textStatus 描述状态的字符串。 error(function):请求失败时调用的函数，有三个参数 function(xhr,textStatus,errorThrown), xhr: ajax对象，即XMLHttpRequest对象。 textStatus和errorThrown，jQuery保证其中的一个参数可以获得异常的描述。 async: true(缺省)/false $(function(){ $(&apos;#s1&apos;).change(function(){ //先清空表格 $(&apos;#tb1&apos;).empty(); $.ajax({ &apos;url&apos;:&apos;carInfo.do&apos;, &apos;type&apos;:&apos;post&apos;, &apos;data&apos;:&apos;carName=&apos; + $(&apos;#s1&apos;).val(), &apos;dataType&apos;:&apos;xml&apos;, &apos;success&apos;:function(data){ //data:服务器返回的数据如果服务器返回的是xml, 浏览器不一样，则生成的dom树的结果也不一样，为了方便解析dom树，一般 我们使用$()函数将其转换成jQuery对象,然后进行遍历或者查找。 $(&apos;#tb1&apos;).append( &apos;&lt;tr&gt;&lt;td&gt;价格:&apos; + $(data).find(&apos;price&apos;).text() + &apos; 车重:&apos; + $(data).find(&apos;weight&apos;).text() + &apos;&lt;/td&gt;&lt;td&gt;门数:&apos; + $(data).find(&apos;doors&apos;).text() + &apos; 长宽高:&apos; + $(data).find(&apos;size&apos;).text() + &apos;&lt;/td&gt;&lt;td&gt;排量:&apos; + $(data).find(&apos;vol&apos;).text() + &apos; 加速性能:&apos; + $(data).find(&apos;speed&apos;).text() + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;); $(&apos;#d2&apos;).show(); setTimeout(function(){ $(&apos;#d2&apos;).fadeOut(&apos;slow&apos;); },3000); }, &apos;error&apos;:function(){ alert(&apos;服务暂时不可用&apos;); } }); }); }); 10、给JQuery添加插件可以把JQuery看做一个类，给JQuery添加插件就是给Jquery类中添加方法。相当于在Java中给String类增加方法（当然是不可以增加的），这样就可以用JQuery对象直接调用了，方便多次使用。 使用场合：使用频率高的方法， JQuery经典总结 eg:下面代码的作用是对指定的文本框(errorContent)进行非空验证，并输出（errorMsg）验证提示信息。 写法一： $.fn.required = function(errorContent, errorMsg) { var val = $(this).val(); if (val != null &amp;&amp; val.length &gt; 0) { $(errorContent).text(&quot;&quot;); return true; } else { $(errorContent).text(errorMsg); return false; } } 写法二： ;(function($){ $.fn.extend({ rangeLength:function(errorContent, errorMsg){ var val = $(this).val(); if (val != null &amp;&amp; val.length &gt; 0) { $(errorContent).text(&quot;&quot;); return true; } else { $(errorContent).text(errorMsg); return false; } } }); })(jQuery) &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&quot;#submit&quot;).bind(&quot;click&quot;,function(){ var b1 = $(&quot;#adminCode&quot;) .required($(&quot;#error_adminCode&quot;),&quot;账号必须填写&quot;); var b2 = $(&quot;#password&quot;) .required($(&quot;#error_password&quot;),&quot;密码必须填写&quot;) if(b1 &amp;&amp; b3) { $(&quot;#loginForm&quot;).submit(); } }); }); &lt;/script&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jquery（二）","date":"2017-03-16T07:55:49.158Z","path":"2017/03/16/jquery（二）/","text":"2030-01-24 22:03:57 星期四 6、事件处理机制 event1)、事件绑订 bind(type,fn) $(function(){ $(&apos;#d1&apos;).bind(&apos;click&apos;,function(){ $(this).html(&apos;hello java&apos;); }); }); 2)、绑订方式的简写形式 $(function(){ $(&apos;#d1&apos;).click(function(){ $(this).html(&apos;hello java&apos;); }); }); 3)、合成事件 hover(mouseenter,leave) : 模拟光标悬停事件，区别于CSS中的伪类 $(&apos;.s1&apos;).hover(function(){ $(this).addClass(&apos;s2&apos;); },function(){ $(this).removeClass(&apos;s2&apos;); }); 相当于以下连个函数的合成： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }); $(&apos;.s1&apos;).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); 上面的mouseenter和mouseleave两个函数可以合并为： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); toggle(fn1,fn2…)：模拟鼠标连续单击事件 $(&apos;#a1&apos;).toggle(function(){ $(&apos;#d1&apos;).show(&apos;slow&apos;); },function(){ $(&apos;#d1&apos;).hide(&apos;slow&apos;); }); 4)、事件冒泡 (1)获得事件对象 依据事件对象获得事件源(即哪一个节点产生了该事件，返回的是原始的DOM节点)，其中e不再是DOM对象，而是封装之后的JQuery对象。 var srcObj = e.srcElement; //ie var srcObj = e.target; //firefox,chrome var srcObj = e.srcElement || e.target; //同时兼容ie,firefox,chrome alert(srcObj.innerHTML); 依据事件对象获得鼠标点击的坐标（相对于屏幕） alert(e.clientX + ‘:’ + e.clientY); (2)事件对象的属性 event.type event.target:返回事件源(是dom对象) event.pageX/pageY 获得相对于当前浏览器页面的坐标 (3)停止冒泡 event.stopPropagation() function clickA(e){ alert(&quot;你点击了一个链接&quot;); //取消冒泡 e.stopPropagation(); } function clickDiv(e){ alert(&quot;你点击了一个Div&quot;); } 上列中，链接处于div中，当取消冒泡后，单击链接便不会触发div上面 onlick事件的执行，上例中的输出结果为：你点击了一个链接 (4)停止默认行为 event.preventDefault() $(function(){ $(&apos;#d1&apos;).click(function(e){ var flag = confirm(&apos;确定删除吗&apos;); if(!flag){ e.preventDefault(); } }); }); 设置停止了默认行为后，表单提交按钮便不会自动提交了。相当于： &lt;input type=”submit” id=”d1” name=”username” onclick=”return fonfirm(‘确定要删除吗’)”/&gt; 5)、模拟操作 trigger(&apos;click&apos;) $(function(){ $(&apos;#b1&apos;).click(function(){ //$(&apos;#username&apos;).trigger(&apos;focus&apos;); $(&apos;#username&apos;).focus(); }); }); 上列模拟了文本框控件获得焦点的行为，当点击按钮后，文本框便获得了焦点，表现为文本框内有光标闪动。 mouseenter和mouseover效果一样，可以互换使用 mouseout和mouseleave效果一样，可以互换使用 7、动画 animate 1)show(), hide() 作用：通过同时改变元素的宽度与高度来实现显示和隐藏的效果。 语法:show(速度,callback); 速度: ‘slow’,’normal’,’fast’ / 800(毫秒) callback: 在动画执行完毕之后，会执行这个函数 $(function(){ $(&apos;#btn1&apos;).click(function(){ $(&apos;#sp1&apos;).hide/show(500); $(&apos;#sp1&apos;).hide/show(500,function(){alert(&quot;H&quot;);}); }); }); 2)、fadeIn() fadeOut() 作用， 通过改变元素的不透明度来实现显示和隐藏的效果。 语法: fadeIn/fadeOut(速度,callback); $(function(){ $(&apos;#btn1&apos;).click(function(){ $(&apos;#sp1&apos;).fadeIn/fadeOut(500); $(&apos;#sp1&apos;).fadeIn/fadeOut(500,function(){alert(&quot;H&quot;);}); }); }); 3)、slideUp() slideDown() 作用：通过改变元素的高度来实现显示和隐藏的效果。 语法: slideUp(速度,callback); $(function(){ $(&apos;#a1&apos;).toggle(function(){ $(&apos;#d1&apos;).slideDown(&apos;slow&apos;); },function(){ $(&apos;#d1&apos;).slideUp(&apos;slow&apos;); }); }); 4)、自定义动画 animate(params,speed,callback) 语法: JQuery经典总结 params:是一个js对象，描述了动画执行结束时元素的样式，比如: {‘top’:’600px’,’left’:’200px’} speed: 毫秒 callback: 在动画执行完毕之后，会执行这个函数 $(this).animate({&apos;left&apos;:&apos;500px&apos;},4000); $(this).animate({&apos;top&apos;:&apos;250px&apos;},2000).fadeOut(&apos;slow&apos;);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jquery（一）","date":"2017-03-16T07:54:57.706Z","path":"2017/03/16/jquery（一）/","text":"2030-01-22 22:20:00 星期二 jQuery基础1)dom对象 — &gt; jQuery对象 var $obj = $(dom对象); var $d = $(div); 2)jQuery对象 —- &gt; dom对象 第一种方式: var obj = $obj.get(0); 第二种方式: var obj = $obj.get()[0]; (3) jQuery与prototype如何同时使用？ 因为jQuery与prototype都使用$函数，需要使用 var $a = jQuery.noConflict()将$函数改名为”$a”。 jQuery选择器1)、基本选择器 selector/a1.html ——&gt; 匹配所有元素 #id ——&gt; 根据给定的ID匹配一个元素。.class ——&gt; 根据给定的类匹配元素。 element ——&gt;根据给定的元素名匹配所有元素selector1,selector2..selectorn ——&gt;将每一个选择器匹配到的元素合并 2)、层次选择器select1 select2——&gt;匹配select1下的所有儿子元素（不包含孙子元素） select1&gt;select2——&gt;匹配select1下的所有子元素（包含孙子元素） select1+select2——&gt;匹配紧跟在select1后的第一个兄弟元素（同辈元素） select1~select2——&gt;匹配select1后的所有兄弟元素（及找到所有的同 3)、过滤选择器a.基本过滤选择器 selector/ a3.html:first——&gt;获取第一个元素 :last——&gt;获取第一个元素 :not(selector)——&gt;获取去除给定元素后的所有匹配元素 :even——&gt;匹配所有索引值为偶数的元素，从 0 开始计数 :odd——&gt;匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index)——&gt;匹配一个给定索引值的元素 :gt(index)——&gt;匹配所有大于给定索引值的元素 :lt(index)——&gt;匹配所有小于给定索引值的元素 b.内容过滤选择器 selector/ a4.html:contains(text)——&gt;匹配包含给定文本的元素 :empty ——&gt;匹配没有子元素且文本为空的元素:has(selector)——&gt;匹配含有选择器所匹配的元素的元素 :parent ——&gt; 跟empty相反,即有子节点，或者内容不为空的节点。 c.可见性过滤选择器 selector/ a5.html:hidden——&gt;匹配所有不可见元素，或者type为hidden的元素 :visible——&gt;匹配所有的可见元素 d.属性过滤选择器 selector/ a6.html[attribute]——&gt;匹配包含给定属性的元素 [attribute=value]——&gt;匹配给定的属性是某个特定值的元素 [attribute!=value]——&gt;匹配属性不等于特定值的元素。 e.子元素过滤选择器 selector/ a7.html:nth-child(index/even/odd)——&gt;匹配其父元素下的第N个子或奇 偶元素（即同辈中第N个元素） :first-child——&gt;匹配其父元素下第一个子元素 :last-child——&gt;匹配其父元素下最后一个子元素 f.表单对象属性过滤选择器 :enabled——&gt;匹配所有可用元素 :disabled——&gt;匹配所有不可用元素 :checked——&gt;匹配复选框、单选按钮中被选中的元素 :selected——&gt;匹配所有选中的option元素 4)、表单选择器:input——&gt;匹配所有 input, textarea, select 和 button 元素 :text——&gt;匹配所有的单行文本框 :pasword——&gt;匹配所有密码框 :radio——&gt;匹配所有单选按钮 :checkbox——&gt;匹配所有复选框 :submit——&gt;匹配所有提交按钮 :image——&gt;匹配所有图像域 :reset——&gt;匹配所有重置按钮 :button——&gt;匹配所有按钮 :file——&gt;匹配所有文件域 :hidden——&gt; 匹配所有不可见元素，或者type为hidden的元素 dom操作1)、查询 dom / d1.html利用选择器找到要操作的节点之后，访问节点的html内容、text内容、节点的值以及节点的属性值。除此之外，还可以修改这些值。 a, html() : 相当于innerHTML b, text(): 获取div,p,span等元素内文本相当于innerText， c, val():获取文本框text、下拉列表select或选择框checkbox的值 d, attr():获取或设置节点的属性值 2)、创建 dom / d2.html$(html); 3)、插入节点append():向每个匹配的元素内部追加内容，当做最后一个儿子 prepend():向每个匹配的元素内部前置内容。当做第一个儿子 after():在每个匹配的元素之后插入内容，当做后一个兄弟 before():在每个匹配的元素之前插入内容，当做前一个兄弟 var $obj = $(&apos;&lt;div&gt;首先是培养兴趣，然后是多写代码&lt;/div&gt;&apos;); $(&apos;body&apos;).append($obj); 也可以简化为 $(&apos;body&apos;).append(&apos;&lt;div&gt;首先是培养兴趣，然后是多写代码&lt;/div&gt;&apos;); 4)、删除节点 dom / d3.htmlremove()：$(‘ul li:eq(1)’).remove(); remove(selector)：$(‘ul li’).remove(‘#l1’); empty():清空节点：$(‘ul li:eq(1)’).empty(); 5)、复制节点 dom / d6.htmlclone():不复制行为 clone(true):使复制的节点也具有行为 6)、属性操作 dom / d7.html读取：attr(‘ ‘); $(“img”).attr(“src”); 设置： attr(‘ ‘,’ ‘) $(“img”).attr(‘src’, ‘test.jpg’); s(&apos;#d1&apos;).attr(&apos;value&apos;,&apos;font-size:40px;color:red;&apos;); $(&apos;#form1 input:disabled&apos;).attr(&apos;disabled&apos;,false); 或者一次设置多个 attr({“”:””,””:””}); eg:$(&apos;div&apos;).attr({&apos;class&apos;:&apos;s1&apos;,&apos;style&apos;:&apos;color:red;&apos;}); 删除：removeAttr(‘ ‘) 7)、样式操作 dom / d8.html 获取和设置: attr(“class”,””), attr(“style”,””); alert($(&apos;div&apos;).attr(&apos;class&apos;)); $(&apos;div&apos;).attr(&apos;class&apos;,&apos;s1&apos;) $(&apos;div&apos;).attr(&apos;style&apos;,&apos;color:blue;&apos;); 追加:addClass(‘’):$(‘div’).addClass(‘s2 s3’); 移除:removeClass(‘’) :$(‘div’).removeClass(‘s3’); 或者removeClass(‘s1 s2’) 或者removeClass()//会删除所有样式 切换样式：toggleClass:$(‘div’).toggleClass(‘s3’); 是否有某个样式 hasClass(‘’):alert($(‘div’).hasClass(‘s3’)); 读取css(‘’) 设置css(‘’,’’)或者css({‘’:’’,’’:’’})//设置多个样式 $(&apos;table tr:first&apos;).css(&apos;background-color&apos;,&apos;#cccccc&apos;); $(&apos;table tr:first&apos;).css({&apos;background-color&apos;:&apos;#cccccc&apos;,’width’:’3px’}); 8)、遍历节点 dom / d9.htmlchildren()/children(selector):var $obj = $(‘#d0’).children(‘div’); 只考虑子元素，不考虑其它后代元素。 next(selector): 下一个兄弟$(‘#d2’).next() prev(selector):上一个兄弟$(‘#d2’).prev() siblings(selector):其它兄弟， $(&apos;#d2&apos;).siblings(‘#id’)除#d2之外的其他兄弟节点 也可以写成：$(‘#id’).siblings() parent():父节点,不是爷爷节点 find(selector): 从当前节点开始，查找所有后代，包括孙子。 事件处理机制 event1)、事件绑订 event/e1.html$(function(){ $(&apos;#d1&apos;).bind(&apos;click&apos;,function(){ $(this).html(&apos;hello java&apos;); }); }); 2)、绑订方式的简写形式上个列子可以简写为： $(function(){ $(&apos;#d1&apos;).click(function(){ $(this).html(&apos;hello java&apos;); }); }); 3)、合成事件 event/e2.html e3.htmlhover(mouseenter,leave) : 模拟光标悬停事件，区别于CSS中的伪类 $(&apos;.s1&apos;).hover(function(){ $(this).addClass(&apos;s2&apos;); },function(){ $(this).removeClass(&apos;s2&apos;); }); 相当于以下连个函数的合成： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }); $(&apos;.s1&apos;).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); 上面的mouseenter和mouseleave两个函数可以合并为： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); toggle(fn1,fn2...)：模拟鼠标连续单击事件 $(&apos;#a1&apos;).toggle(function(){ $(&apos;#d1&apos;).show(&apos;slow&apos;); },function(){ $(&apos;#d1&apos;).hide(&apos;slow&apos;); }); 4)、事件冒泡(1)获得事件对象 event/e4.html e5.html e6.html click(function(e){ }); function f1(e){ 依据事件对象获得事件源(即哪一个节点产生了该事件，返回的是原始的DOM节点)，其中e不再是DOM对象，而是封装之后的JQuery对象。 var srcObj = e.srcElement; //ie var srcObj = e.target; //firefox,chrome var srcObj = e.srcElement || e.target; //同时兼容ie,firefox,chrome alert(srcObj.innerHTML); 依据事件对象获得鼠标点击的坐标（相对于屏幕） alert(e.clientX + &apos;:&apos; + e.clientY); (2)事件对象的属性 event/e6.htmlevent.type event.target:返回事件源(是dom对象) event.pageX/pageY 获得相对于当前浏览器页面的坐标 (3)停止冒泡 event / e7.htmlevent.stopPropagation() function clickA(e){ alert(&quot;你点击了一个链接&quot;); //取消冒泡 e.stopPropagation(); } function clickDiv(e){ alert(&quot;你点击了一个Div&quot;); } 上列中，链接处于div中，当取消冒泡后，单击链接便不会触发div上面 onlick事件的执行，上例中的输出结果为：你点击了一个链接 (4)停止默认行为 event / e8.htmlevent.preventDefault() $(function(){ $(&apos;#d1&apos;).click(function(e){ var flag = confirm(&apos;确定删除吗&apos;); if(!flag){ e.preventDefault(); } }); }); 设置停止了默认行为后，表单提交按钮便不会自动提交了。相当于： &lt;input type=”submit” id=”d1” name=”username” onclick=”return fonfirm(‘确定要删除吗’)”/&gt; 5)、模拟操作 event / e9.htmltrigger(&apos;click&apos;) $(function(){ $(&apos;#b1&apos;).click(function(){ //$(&apos;#username&apos;).trigger(&apos;focus&apos;); $(&apos;#username&apos;).focus(); }); }); 上列模拟了文本框控件获得焦点的行为，当点击按钮后，文本框便获得了焦点，表现为文本框内有光标闪动。 mouseenter和mouseover效果一样，可以互换使用 mouseout和mouseleave效果一样，可以互换使用","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"AJAX","date":"2017-03-16T07:54:22.632Z","path":"2017/03/16/AJAX/","text":"1/22/2017 9:40:51 PM 原生JavaScript的AJAX首先，获取XHR对象，它被内嵌在浏览器中了，主要为了区别IE6这类特殊浏览器，不然直接调用XMLHttpRequest这个方法即可获取。成功获取对象之后使用open（）方法传入请求方法，请求url。这个onreadystatechange是一个回调函数，负责接收服务器响应数据的处理，这里类似将它重写，浏览器会调用这个方法处理返回数据。send方法在GET请求中只需要传入null，因为send方法是把数据放在请求体内，只有POST方式才会往send里写数据。回调函数的写法是按照视频代码抄写的。在responseText可以获得服务端写来的数据。 var XHR=false; function createXHR(){ if(window.XMLHttpRequest){ XHR=new XMLHttpRequest(); }else{ XHR=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } } function checkUsername(){ var username=document.getElementById(&quot;check&quot;).value; createXHR(); XHR.open(&quot;get&quot;,&quot;checkUsername?username=&quot;+username,true); XHR.onreadystatechange=showMsgCallback; XHR.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); XHR.send(); } function showMsgCallback(){ if(XHR.readyState==4){ if(XHR.status==200){ var text=XHR.responseText.toString(); alert(text==&apos;no&apos;); console.log(text); if(text==&quot;yes&quot;){ alert(1); document.getElementById(&quot;msg&quot;).innerHTML=&quot;此用户名已注册!&quot;; } else if(text==&quot;no&quot;) { alert(2); document.getElementById(&quot;msg&quot;).innerHTML=&quot;此用户可以注册&quot;; } } } } 三种Jquery的ajax写法&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ajax交互&lt;/title&gt; &lt;script src=&quot;jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() { $(&apos;#button1&apos;).click(function() { var text = $(&apos;#msg1&apos;); $.ajax({ type : &quot;POST&quot;, url : &quot;jquery&quot;, data : &quot;username=ssss&quot;, dataType : &apos;text&apos;, success : function(result) { if (result==&quot;success&quot;) { text.text(&quot;&quot;); text.append(&quot;成功&quot;); }else{ text.text(&quot;&quot;); text.append(&quot;失败&quot;); } }, error : function() { text.text(&quot;&quot;); text.append(&quot;操作出错&quot;); } }); }); }); $(document).ready(function(){ $(&apos;#button2&apos;).click(function(){ var text = $(&apos;#msg2&apos;); $.post(&apos;jquery&apos;, &apos;username=xxxx&apos;,function(result){ if (result===&quot;success&quot;) { text.text(&quot;成功&quot;); }else{ text.text(&quot;失败&quot;); } },&apos;text&apos;); }); }); $(document).ready(function(){ $(&apos;#button3&apos;).click(function(){ var text = $(&apos;#msg3&apos;); $.get(&apos;jquery&apos;,&apos;username=zzzzz&apos;,function(result){ if (result===&quot;success&quot;) { text.text(&quot;成功&quot;); }else{ text.text(&quot;失败&quot;); } }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;button1&quot;&gt;点击使用$ajax发送&lt;/button&gt; &lt;span id=&quot;msg1&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;button id=&quot;button2&quot;&gt;点击使用$post发送&lt;/button&gt; &lt;span id=&quot;msg2&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;button id=&quot;button3&quot;&gt;点击使用$get发送&lt;/button&gt; &lt;span id=&quot;msg3&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;/body&gt; &lt;/html&gt; 应用&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; &lt;%@ taglib prefix=&quot;sx&quot; uri=&quot;/struts-dojo-tags&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;AJAX范例&lt;/title&gt; &lt;sx:head/&gt; &lt;script src=&quot;jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&apos;#usrname&apos;).blur(function(){ $.ajax({ type : &quot;POST&quot;, url : &quot;checkUsername&quot;, data : &apos;name=&apos;+$(&apos;#usrname&apos;).val(), dataType : &apos;text&apos;, success:function(data){ if(data===&apos;yes&apos;) $(&apos;#msg&apos;).text(&apos;可以登录&apos;); else if(data===&apos;no&apos;) $(&apos;#msg&apos;).text(&apos;无法登录&apos;); } }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;form action=&quot;&quot;&gt; &lt;span id=&quot;msg&quot;&gt;&lt;/span&gt;&lt;br/&gt; 用户名:&lt;input id=&quot;usrname&quot; name=&quot;name&quot; type=&quot;text&quot;/&gt; &lt;br/&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot;/&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"新建,模板,小书匠","slug":"新建-模板-小书匠","permalink":"http://yoursite.com/tags/新建-模板-小书匠/"}]},{"title":"DOM","date":"2017-03-16T07:53:42.784Z","path":"2017/03/16/DOM/","text":"2017-01-21 22:29:04 星期一 DOM即文件对象模型（Document Object Model，简称DOM）HTML DOM 定义了访问和操作 HTML 文档的标准方法。简言之： （1）其实它就是将 HTML 文档以节点（Node）为单位将其表达为等级明确、节构整齐的树节构，以便于简捷地操作文档的元素。 （2）它在一定程度上对HTML（或XML）元素（节点）实现了“黑盒”访问和操作。例如，我们获得了一个节点对象，然后直接用它的parentNode属性获得它的父节点（如果父节点存在的话），进而访问或操作父节点对象，而我们无需知道它的父节点是什么类型的对象，它的id是什么等等，父节点就是封装好的一个“黑盒”，我们不知道它的id、name等所有属性，依然可以利用dom技术随意操作它。 DOM对节点（Node）的定义：Ø 整个文档是一个文档节点Ø 每个 HTML 标签是一个元素节点Ø 包含在 HTML 元素中的文本是文本节点Ø 每一个 HTML 属性是一个属性节点Ø 注释属于注释节点 DOM中节点的层级关系层级关系很明确也很简单，根据节点之间的关系将其分为三种：父（parent）、子（child）、同胞（sibling） DOM对象树DOM将每一个HTML或XML的文档都看待成内存中的一个对象树浏览器中的一个页面对应一个HTML文档，因此有一颗与之对应的HTML的DOM树。浏览器中一个页面可能处理很多个XML的文档，因此可能有很多颗XML的DOM树。 DOM对象树种的常用节点 接口 nodeType常量（IE不支持） nodeType值 备注 Element Node.ELEMENT_NODE 1 元素节点（标签） Atrr Node.ATTRIBUTE_NODE 2 属性节点（属性） Text Node.TEXT_NODE 3 文本节点（文本） Comment Node.COMMENT_NODE 8 注释节点（注释） Document Node.DOCUMENT_NODE 9 文本根节点 DOM对象树不同节点的名值对比 节点 nodeName（节点名） nodeValue(节点值) Element元素节点 对应标签名的大写形式如：HTML Null Attr属性节点 文档中定义的属性名如：type 文档中定义的属性值如：button Text文本节点 #text 文本内容如：133 Comment注释节点 #comment 注释内容如：comment Document根节点 #document Null 根节点的属性和方法：&lt;script type=&quot;text/javascript&quot; &gt; function testapi(){ //获得根节点元素 var htmlrootElement=document.documentElement; //获得指定的元素节点 var divNode=document.getElementById(&quot;div1&quot;); //获得整个页面所有的div元素节点 var divNodes=document.getElementsByTagName(&quot;div&quot;); //创建元素节点 var newdivNode=document.createElement(&quot;div&quot;); //创建文本节点 var newTextNode=document.createTextNode(&quot;aaaa&quot;); } &lt;/script&gt; 元素节点的属性和方法//根据标签名获得元素节点 var divNode2=document.getElementById(&quot;div2&quot;); var divNodes2=divNode2.getElementsByTagName(&quot;div&quot;); //操作属性 var inputtext=document.getElementById(&quot;inputtext&quot;); var flag=inputtext.hasAttribute(&quot;value&quot;); inputtext.setAttribute(&quot;value&quot;, &quot;aaacede&quot;); var textValue=inputtext.getAttribute(&quot;value&quot;); flag=inputtext.hasAttribute(&quot;value&quot;); inputtext.removeAttribute(&quot;value&quot;); alert(&quot;完成&quot;); 所有节点（Node）都拥有的属性和方法 //返回元素节点包含的属性节点 var attributes=inputtext.attributes; //nodeName nodeValue nodeType var inputName=inputtext.nodeName; var nodetype=inputtext.nodeType; var nodevalue=inputtext.nodeValue; //获取所有的子节点 var childs=divNode2.childNodes; //获取父节点 var parent=divNode2.parentNode; //获取第一个子节点和最后一个子节点 var first=divNode2.firstChild; var last=divNode2.lastChild; //获取兄弟节点 var next=divNode2.nextSibling; var last=divNode2.previousSibling; //判断是否有子节点 var flag2=divNode2.hasChildNodes(); //追加节点 newdivNode.appendChild(newTextNode); divNode2.appendChild(newdivNode); var new2=document.createElement(&quot;div&quot;); var text2=document.createTextNode(&quot;insert&quot;); new2.appendChild(text2); divNode2.insertBefore(new2,divNode2.firstChild); var new3=document.createElement(&quot;div&quot;); var text3=document.createTextNode(&quot;insert3&quot;); new3.appendChild(text3); divNode2.insertBefore(new3, null); divNode2.insertBefore(new3,divNode2.firstChild); //移除节点 var remove=divNode2.removeChild(new3); var new4=document.createElement(&quot;div&quot;); var text4=document.createTextNode(&quot;insert4&quot;); new4.appendChild(text4); //如果第一个参数曾经是当前节点的子节点，那么这个参数对应的节点会被移动到第二个参数对应的节点的位置。 //第二个参数对应的节点被删除了。 var replace=divNode2.replaceChild(new4,divNode2.getElementsByTagName(&quot;div&quot;)[0]); //clone节点 var clone1=divNode2.cloneNode(true); var clone2=divNode2.cloneNode(false); AJAX,DOM 和javascript的关系DOM能够为javascript引擎公开网页。通过DOM，可以采用编程的方式操作文档的结构。Web页面的DOM表示是一个树状结构，由元素或点组成。节点可以包含很多子节点。javascript通过全局变量document公开当前Webde根节点，这个变量是所有DOM操作的起点。DOM使用容器的属性来做索引，而不是使用数字做索引。DOM中元素的关系可以看作是HTML清单的镜像。这种关系可以是双向的，修改DOM将改变HTML标记，随之会反映在页面的现实上。用一个简单一点的关系表示就是：DOM–数据–&gt;jQuery–利用–&gt;Ajax–请求–&gt;后台后台–回应Ajax请求–&gt;Jquery–操作dom变现请求–&gt;dom","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"flag","date":"2017-03-16T07:52:45.629Z","path":"2017/03/16/flag/","text":"2017-01-20 21:34:57 星期日今天没学习 该打 偶然看到入门前端学习路线 立个flag 静心 慢慢学吧~ 一、学习HTML5和CSS3基础随着这移动互联网快速发展的时代，尤其是4G时代，HTML5+CSS3已然成为新一代的web前端技术。 随着HTML5的发展和普及，了解 HTML5 也将成为 Web开发人员的必修课。涉及到网页外观时，就需要学习 CSS 了，它可以帮你把网页做得更美观。 利用 HTML5 和 CSS3 模拟一些你所见过的网站的排版和布局（色彩，图片，文字样式等等）。 如：京东首页的实现 当然，达内Web前端开发课程第一阶段还会学习 PS设计工具使用和互联网UI设计理论。在阶段项目实战中，大家常见的京东详情页、360专题页、淘宝首页都可以实现。 二、学习JavaScript，了解DOMJavaScript 是一种能让你的网页更加生动活泼的程序语言。学习 JavaScript 的基本语法，学会用 JavaScript 操作网页中 DOM 元素。 在达内 Web前端开发课程第二阶段完全可以实现大家平常喜欢玩的 2048 游戏。（是不是感觉挺有意思） 接着学习使用一些 JavaScript 库，比如 Jquery 是大部分 Web开发人员都喜欢用的，通过 Jquery 可以有效的提高 JavaScript 的开发效率。 三、学习Web前端核心学习 Jquery 之后，大家就要学习 HTML5 高级阶段（HTML5 Canvas 绘图、HTML5 SVG、音频和视频处理、表单处理、表单验证…等） 达内培训每学习一个阶段，都是让学员真正进行项目实战，在熟悉和消化所学习知识的同时，增加自己的项目经验和团队协作能力。 在学习 Jquery 和 HTML5 学习结束后，就可以完成飞机大战、飞扬的小鸟以及复杂订单的实现。 四、学习HTTP协议及Server端技术服务器端脚本编程（后台开发）也是Web开发人员的基本功之一，达内学员现在学习的是最流行的php。 要构建动态页面通常会使用到数据库，通常PHP使用Oracle、MySQL数据库。 对于Web服务器来说，Apache 一个就已经是了。那么Apache、php、数据库，该怎么理解它们的关系？ 1、Apache是服务器基础，php和数据库都需要Apache来协调工作 2、php是脚本解释，如果不用php，那么Apache出来的东西就只是静态的，而不能在服务器实现功能 3、数据库完全可以单独使用，但是和Apache、php一起，则是由php代码调用数据库接口，而apache就负责解释php代码，让他能真正地实现对数据库的调用 这个阶段的项目实战是实现京东订单页和个人论坛。 五、学习Web前端高级技术当你掌握了HTML5，CSS3，JavaScript等技术之后，就应该找一个Web框架加快你的Web开发速度，使用框架可以节约你很多时间。 在达内学习的Bootstrap是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷，是web前端开发者最喜欢，也是现在企业里最常用的前端框架。 Angular JS是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC编程、模块化、控制器、路由、事件绑定等等。 AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发。如同其他的抽象技术一样，这也会损失一部分灵活性。换句话说，并不是所有的应用都适合用AngularJS来做。AngularJS主要考虑的是构建CRUD应用。幸运的是，至少90%的WEB应用都是CRUD应用。但是要了解什么适合用AngularJS构建，就得了解什么不适合用AngularJS构建。 从最简单的HTML5基础到Web前端高级技术，内容还是不少滴！要想精通这里的每一样技术，都得下苦功夫才行。四个月的时间，在达内讲师的指导下，足够你对Web前端开发产生一个有效的认识，并且找到理想的工作。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js鼠标事件改变样式","date":"2017-03-16T07:51:50.681Z","path":"2017/03/16/js鼠标事件改变样式/","text":"2017-01-19 21:37:48 星期六1. z-index当你定义的CSS中有position属性值为absolute、relative或fixed，用z-index此取值方可生效。此属性参数值越大，则被层叠在最上面。 2 .标签中的 href=”javascript:;”javascript:是表示在触发默认动作时，执行一段JavaScript代码，而 javascript:; 表示什么都不执行，这样点击时就没有任何反应。一般在这种情况下，会给绑定一个事件回调，来执行业务，如： document.getElementById(&apos;jsPswEdit&apos;).addEventListener(&apos;click&apos;, function(e) { e.preventDefault(); // 当&lt;a&gt;触发click时，处理业务 }, false); href=”javascript:;”就是去掉a标签的默认行为，跟href=”javascript:void(0)”是一样的，void 是JavaScript 的一个运算符，void(0)就是什么都不做的意思 3 .详解href=”#”与href=”javascript:void(0)”的区别“#”包含了一个位置信息默认的锚点是#top 也就是网页的上端而javascript:void(0) 仅仅表示一个死链接这就是为什么有的时候页面很长浏览链接明明是＃可是跳动到了页首而javascript:void(0) 则不是如此所以调用脚本的时候最好用void(0)或者 、等 4 .getComputedStyle、currentStyle的区别与用法getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读，而element.style能读能写。getComputedStyle方法IE6~8是不支持的。 currentStyle是IE浏览器的一个属性，其与element.style在使用形式上类似，element.currentStyle，差别在于element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的属性等）。因此，从作用上将，getComputedStyle方法与currentStyle属性走的很近，形式上则style与currentStyle走的近。不过，currentStyle属性貌似不支持伪类样式获取，这是与getComputedStyle方法的差异。 5 .CSS伪类CSS伪类是选择符的螺栓，用来指定一个或者与其相关的选择符的状态。它们的形式是selector:pseudoclass{property:value;}，简单地用一个半角英文冒号(:)来隔开选择符和伪类。 CSS很多的建议并没有得到浏览器的支持，但有四个可以安全使用的用在连接上的CSS伪类。 ◆link用在为访问的连接上。 ◆visited用在已经访问过的连接上。 ◆hover用于鼠标光标置于其上的连接。 ◆active用于获得焦点(比如，被点击)的连接上。 鼠标移入移除改变样式实现代码 * Created by YYD on 2017/1/19. */ function getStyle(obj,name) { if(obj.currentStyle){ return obj.currentStyle[name]; } else { return getComputedStyle(obj,false)[name]; } } function startMove(obj,attr,iTarget) { clearInterval(obj.timer); obj.timer=setInterval(function () { var cur=0; if(attr==&quot;opacity&quot;){ cur=Math.round(parseFloat(getStyle(obj,attr))*100); } else { cur=parseInt(getStyle(obj,attr)); } var speed=(iTarget-cur)/6; speed=speed&gt;0?Math.ceil(speed):Math.floor(speed); if(cur==iTarget){ clearInterval(obj.timer); } else{ if(attr==&quot;opacity&quot;){ obj.style.filter=&quot;alpha(opacity:&quot;+(cur+speed)+&quot;&quot;; obj.style.opacity=(cur+speed)/10; document.getElementById(&quot;txt1&quot;).value=obj.style.opacity; } else { obj.style[attr]=cur+speed+&quot;px&quot;; } } },30); }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js悬浮框的实现","date":"2017-03-16T07:50:53.804Z","path":"2017/03/16/js悬浮框的实现/","text":"2016-01-18 23:16:36 星期五 悬浮框随页面滚动而固定于当前页面某一位置实现代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #div1{ width:150px;height: 200px;background: red;position:absolute;left:-150px;} #div1 span{ position:absolute;width: 20px;height:60px;line-height: 20px;background: blueviolet;right: -20px;top:70px; } &lt;/style&gt; &lt;script&gt; window.onscroll=function () { var oDiv=document.getElementById(&quot;div1&quot;); var scrollTop=document.documentElement.scrollTop||document.body.scrollTop; oDiv.style.top=document.documentElement.clientHeight=oDiv.offsetHeight+scrollTop+&quot;px&quot;; } window.onload=function () { var oDiv=document.getElementById(&quot;div1&quot;); oDiv.onmouseover=function () { startMove(10,0); } oDiv.onmouseout=function () { startMove(-10,-150); } }; var timer=null; function startMove(speed,target) { var oDiv=document.getElementById(&quot;div1&quot;); clearInterval(timer); timer=setInterval(function () { if(oDiv.offsetLeft==target){ clearInterval(timer); } else { oDiv.style.left=oDiv.offsetLeft+speed+&quot;px&quot;; } },30) } &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;height: 2000px&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;span&gt;分享到&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 1、各浏览器下 scrollTop的差异IE6/7/8：对于没有doctype声明的页面里可以使用 document.body.scrollTop 来获取 scrollTop高度 ；对于有doctype声明的页面则可以使用 document.documentElement.scrollTop；Safari:safari 比较特别，有自己获取scrollTop的函数 ： window.pageYOffset ；Firefox:火狐等等相对标准些的浏览器就省心多了，直接用 document.documentElement.scrollTop ； 2、获取scrollTop值完美的获取scrollTop 赋值短语 ：var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; 通过这句赋值就能在任何情况下获得scrollTop 值。仔细观察这句赋值，你发现啥了没？？没错， 就是 window.pageYOffset (Safari) 被放置在 || 的中间位置。因为当 数字0 与 undefine 进行 或运算时，系统默认返回最后一个值。即或运算中 0 == undefine ;当页面滚动条刚好在最顶端，即scrollTop值为 0 时。 IE 下 window.pageYOffset (Safari) 返回为 undefine ，此时将window.pageYOffset (Safari) 放在或运算最后面时， scrollTop 返回 undefine , undefine 用在接下去的运算就会报错咯。而其他浏览器 无论 scrollTop 赋值或运算顺序如何都不会返回 undefine. 可以安全使用..所以说到头还是IE的问题咯. 杯具…精神有点恍惚，不知道有没有表达清楚。不过最后总结出来这句实验过OK，大家放心使用；var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; DTD相关说明：页面具有 DTD，或者说指定了 DOCTYPE 时，使用 document.documentElement。 页面不具有 DTD，或者说没有指定了 DOCTYPE，时，使用 document.body。 在 IE 和 Firefox 中均是如此。 为了兼容，不管有没有 DTD，可以使用如下代码： var scrollTop = window.pageYOffset //用于FF || document.documentElement.scrollTop || document.body.scrollTop || 0;documentElement 和 body 相关说明： body是DOM对象里的body子节点，即 标签； documentElement 是整个节点树的根节点root，即 标签； DOM把层次中的每一个对象都称之为节点，就是一个层次结构，你可以理解为一个树形结构，就像我们的目录一样，一个根目录，根目录下有子目录，子目录下还有子目录。 以HTML超文本标记语言为例：整个文档的一个根就是,在DOM中可以使用document.documentElement来访问它，它就是整个节点树的根节点。而body是子节点，要访问到body标签，在脚本中应该写：document.body。以HTML超文本标记语言为例：整个文档的一个根就是,在DOM中可以使用document.documentElement来访问它，它就是整个节点树的根节点。而body是子节点，要访问到body标签，在脚本中应该写：document.body。 图片的出现其实就是定时器让图片移出来，到图片全部显示再关闭定时器。移入移出的速度不是有定时器的时间来控制，而是通过每次增加的px的值来控制。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js表单搜索、编辑操作","date":"2017-03-16T07:48:00.288Z","path":"2017/03/16/js表单搜索、编辑操作/","text":"在页面上实现表单数据的添加、搜索等功能一.添加表单内容，隔行变色oTab.tBodies[0].removeChild(this.parentNode.parentNode)1.这里的tBodies相当于document.getElementByTagName(“tbody”)2.removeChild该对象指的是它的子标签，比如tr包着td,那td就是tr的子元素。3.parentNode，同理，获取父级节点。4.昨天的innerHTML就是把某个值设置到该标签里去，看这句就能理解了–&gt; oTd.innerHTML=oAge.value;5.var oID=oTab.tBodies[0].rows.length+1; oTd.innerHTML=oID++;这两句实现了ID不重用（和数据库里的ID一个道理） 下面是表单数据增加，隔行变色的实现代码。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;script&gt; window.onload=function(){ var oTab=document.getElementById(&quot;tab1&quot;); var oBtn=document.getElementById(&quot;btn1&quot;); var oName=document.getElementById(&quot;name&quot;); var oAge=document.getElementById(&quot;age&quot;); var oID=oTab.tBodies[0].rows.length+1; oBtn.onclick=function () { var oTr=document.createElement(&quot;tr&quot;); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=oID++; oTr.appendChild(oTd); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=oName.value; oTr.appendChild(oTd); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=oAge.value; oTr.appendChild(oTd); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=&quot;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&quot;; oTd.getElementsByTagName(&quot;a&quot;)[0].onclick=function () { oTab.tBodies[0].removeChild(this.parentNode.parentNode) } oTr.appendChild(oTd); oTab.tBodies[0].appendChild(tr); } var oldColor=&quot;&quot;; for(var i=0;i&lt;oTab.tBodies[0].rows.length;i++){ oTab.tBodies[0].rows[i].onmouseover=function () { oldColor=this.style.background; this.style.background=&quot;red&quot;; } oTab.tBodies[0].rows[i].onmouseout=function () { this.style.background=oldColor; } if(i%2){ oTab.tBodies[0].rows[i].style.background=&quot;#ccc&quot;; } else { oTab.tBodies[0].rows[i].style.background=&quot;&quot;; } } } &lt;/script&gt; &lt;body&gt; 姓名：&lt;input id=&quot;name&quot; type=&quot;text&quot; /&gt; 年龄：&lt;input id=&quot;age&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;添加&quot;/&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;操作&quot;/&gt; &lt;table border=&quot;5px&quot; width=&quot;500px&quot; ID=&quot;tab1&quot;&gt; &lt;thead&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;BLUE&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 二. 搜索：主要是关键字和忽略大小写的两个函数的使用toLowerCase()、search().(oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase()).search(oName.value.toLowerCase())!=-1 完整代码如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;script&gt; window.onload=function(){ var oTab=document.getElementById(&quot;tab1&quot;); var oBtn=document.getElementById(&quot;btn1&quot;); var oName=document.getElementById(&quot;name&quot;); oBtn.onclick=function () { for(var i=0;i&lt;oTab.tBodies[0].rows.length;i++){ if((oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase()).search(oName.value.toLowerCase())!=-1){ oTab.tBodies[0].rows[i].style.background=&quot;yellow&quot;; } else{ oTab.tBodies[0].rows[i].style.background=&quot;&quot;; } } } } &lt;/script&gt; &lt;body&gt; 姓名：&lt;input id=&quot;name&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;搜索&quot;/&gt; &lt;table border=&quot;5px&quot; width=&quot;500px&quot; ID=&quot;tab1&quot;&gt; &lt;thead&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;BLUE&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 在家学习不静心，学着学着就出去吃东西，哎喂，你说，为什么垃圾食品那么好吃？","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS3 2D3D转换","date":"2017-03-16T07:46:36.788Z","path":"2017/03/16/CSS3 2D3D转换/","text":"一、transform transform: translate(50px,100px);通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数 transform: rotate(30deg);通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 transform: scale(2,4);通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： transform: skew(30deg,20deg);通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数： transform:matrix(0.866,0.5,-0.5,0.866,0,0);matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 二、3D转换transform不仅可以实现2D转换，还可以实现3D转换 2.1 translate移动/沿着X轴的正方向移动45px/transform: translateX(45px);/沿着Y轴的正方向移动45px/transform: translateY(45px);/沿着Z轴的正方向移动45px/transform: translateZ(45px); 2.2 rotate旋转transform: rotate(45deg);// 让元素在平面2D中旋转transform: rotateX(45deg);// 让元素沿着X轴转45度transform: rotateY(45deg);// 让元素沿着Y轴转45度transform: rotateZ(45deg);// 让元素沿着Z轴转45度 2.3 perspective透视电脑显示屏是一个2D的平面，因为我们看不出来旋转的方向，通过perspective属性，可以定义3D 元素距视图的距离，单位是px。说白了，设置了perspective属性后，就有了进大远小的效果了，在视觉上，让我们能看出来3d的效果。注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。perspective：500px;关于近大远小：对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。 2.4坐标系用X、Y、Z分别表示空间的3个维度，三条轴互相垂直。注意+Y是向下的。 2.5transform-styletransform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加。flat:默认值，2d显示preserve-3d: 3d显示 &lt;!--3D导航--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *{ padding: 0; margin:0; } ul{ list-style: none; width: 800px; height: 40px; border: 1px solid #000; margin:200px auto; } li{ width: 100px; height: 40px; position: relative; transform-style: preserve-3d; transition: all 1s; float:left; } li:hover{ transform: rotateX(-90deg); } span{ width: 100px; height: 40px; display: block; position: absolute; top:0; left:0; line-height: 40px; text-align: center; } span:nth-child(1){ background-color: green; transform: translateZ(20px); } span:nth-child(2){ background-color: red; transform: rotateX(90deg) translateZ(20px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--立方体--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box{ width: 200px; height: 200px; border: 1px solid #000; margin: 200px auto; position: relative; transform-style: preserve-3d; transition:all 4s; } .box:hover{ transform:rotateX(360deg) rotateY(360deg); } .m{ width: 100%; height: 100%; position: absolute; top:0; left: 0; font-size: 64px; line-height: 200px; text-align: center; color: black; } .m:nth-child(1){ background-color:red ; transform:translateZ(100px); } .m:nth-child(2){ background-color:yellow ; transform: rotateX(90deg) translateZ(100px); } .m:nth-child(3){ background-color:darkred ; transform: rotateX(180deg) translateZ(100px); } .m:nth-child(4){ background-color:deeppink ; transform: rotateX(270deg) translateZ(100px); } .m:nth-child(5){ background-color:green ; transform: rotateY(90deg) translateZ(100px); } .m:nth-child(6){ background-color:green ; transform: rotateY(270deg) translateZ(100px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;m&quot;&gt;font&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;22&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;33&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;44&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;55&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"js图片滚动和动态时钟的实现","date":"2017-03-16T07:45:27.335Z","path":"2017/03/16/js图片滚动和动态时钟的实现/","text":"2016-01-16 22:59:14 星期三js定时器有以下两个方法： setInterval():按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到clearInterval()被调用或窗口被关闭。 setTimeout():在指定的毫秒数后调用函数或计算表达式。 语法setInterval（code，millisec）setTimeout(code，millisec) 属性 说明 code 必须有。要调用的函数或要执行的代码串 millisec 必须有。周期性执行或调用code之间的时间间隔，以毫秒计 &lt;script type=&quot;text/javascript&quot;&gt; //在网页上输出：今天的日期、星期、现在的时间（动态时钟） function start() { var today=new Date(); var year=today.getFullYear(); var month=today.getMonth()+1; var day=today.getDate(); var hours=today.getHours(); var minutes=today.getMinutes(); var seconds=today.getSeconds(); //如果是单位数字，前面补0 month=month&lt;10? &quot;0&quot;+month :month; day=day&lt;10? &quot;0&quot;+day :day; hours=hours&lt;10? &quot;0&quot;+hours :hours; minutes=minutes&lt;10? &quot;0&quot;+minutes :minutes; seconds=seconds&lt;10? &quot;0&quot;+seconds :seconds; //时间信息连成字符串 var str=&quot;今天是&quot;+year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日 &quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds; //获取id=result的内容 var obj=document.getElementById(&quot;result&quot;); obj.innerHTML=str; //延时器 window.setTimeout(&quot;start()&quot;,1000); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;start()&quot;&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;/body&gt; 几个对象属性innerHTML:设置或获取位于对象起始和结束标签内的HTMLscrollHeight:获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标offsetParent属性指定的父坐标的高度。 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;title&gt;图片滚动&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;!-- #demo { background: #FFF; overflow:hidden; border: 1px dashed #CCC; width: 500px; } #demo img { border: 3px solid #F2F2F2; } #indemo { float: left; width: 800%; } #demo1 { float: left; } #demo2 { float: left; } --&gt; &lt;/style&gt; &lt;div id=&quot;demo&quot;&gt; &lt;div id=&quot;indemo&quot;&gt; &lt;div id=&quot;demo1&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;demo2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; &lt;!-- var speed=10; var tab=document.getElementById(&quot;demo&quot;); var tab1=document.getElementById(&quot;demo1&quot;); var tab2=document.getElementById(&quot;demo2&quot;); tab2.innerHTML=tab1.innerHTML; function Marquee(){ if(tab2.offsetWidth-tab.scrollLeft&lt;=0) tab.scrollLeft-=tab1.offsetWidth else{ tab.scrollLeft++; } } var MyMar=setInterval(Marquee,speed); tab.onmouseover=function() {clearInterval(MyMar)}; tab.onmouseout=function() {MyMar=setInterval(Marquee,speed)}; --&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"复习JS语法","date":"2017-03-16T07:41:57.285Z","path":"2017/03/16/复习JS语法/","text":"js复习2017-03-02 19:24:15 星期四 数值类型&lt;script&gt; var a=3,b=&quot;4&quot;; alert(a+(b-0)); &lt;/script&gt; 不定参 function sum() { //alert(arguments.length) var result=0; for(var i=0;i&lt;arguments.length;i++){ result+=arguments[i]; } alert(result); } sum(11,22,33); css函数 //css(oDiv,’width’)获取样式 //css(oDiv,&apos;width&apos;，&apos;300px&apos;)设置样式 function css() { if(arguments.length==2){ return arguments[0].style[arguments[1]]; } else { arguments[0].style[arguments[1]]=arguments[2]; } } // 与上面等价，简化写法 function css(obj,name,value) { alert(obj=arguments[0]); if(arguments.length==2) { return obj.style[name]=value; } else { obj.style[name]=value; } } window.onload=function () { var oDiv=document.getElementById(&apos;div1&apos;); alert(css(oDiv,&apos;height&apos;)); css(oDiv,&apos;background&apos;,&apos;pink&apos;); css(oDiv,&apos;background&apos;,&apos;red&apos;); } - CSS样式的优先级标签： 1、相同权值情况下，CSS样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）： 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 2、权值不同时，浏览器是根据权值来判断使用哪种css样式的，哪种样式权值高就使用哪种样式。 下面是权值的规则： 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码： p{color:red;} /标签，权值为1/ p span{color:green;} /两个标签，权值为1+1=2/ p&gt;span{color:purple;}/权值与上面的相同，因此采取就近原则/ .warning{color:white;} /类选择符，权值为10/ p span.warning{color:purple;} /权值为1+1+10=12/ footer .note p{color:yellow;} /权值为100+10+1=111/ 注意：（1）还有一个权值比较特殊——继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。（继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。如便签内部的标签就会继承该标签的样式）； （2）做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，可以使用!important来解决。如下代码：p{color:red!important; /*!important要写在分号前}这里注意当网页制作者不设置css样式时，浏览器会按照自己的一套样式来显示网页。并且用户也可以在浏览器中设置自己习惯的样式，比如有的用户习惯把字号设置为大一些，使其查看网页的文本更加清楚。这时注意样式优先级为：浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。 3、使用JS对样式进行操作时往往可通过两种方式：object.style.property=new style和object.className = new classname。前者是修改行间样式，JS代码执行后，审查元素可看到样式会直接显示在行间代码中，如：技术分享；后者则是在行间增加了新的class，而不会将具体的样式代码显示出来。 获取非行间样式 if(oDiv.currentStyle){ alert(oDiv.currentStyle.width); } else { alert(getComputedStyle(oDiv,true).width); } 数组操作var arr=[1,2,3,4,5,6]; // arr.push(0);从数组的尾部的添加 //arr.pop();从数组尾部开始删除 //arr.shift();从头部开始删除 //arr.unshift(8);从头部开始添加 //从中间任意位置删除，插入，替换 splice(起点，长度) //arr.splice(2,3); //arr.splice(2,0,&apos;a&apos;,&apos;s&apos;,&apos;d&apos;); arr.splice(2,2,&apos;x&apos;,&apos;y&apos;);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]