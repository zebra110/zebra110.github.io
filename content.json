[{"title":"meta","date":"2017-05-23T05:34:15.066Z","path":"2017/05/23/2017-5-16未命名文件/","text":"响应式页面 12&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; // 不要缩放 123img&#123; max-width:100%; &#125; meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的标记和标记之间，它提供用户不可见的信息。meta标签通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie；它可以用于鉴别作者，设定页面格式，标注内容提要和关键字；还可以设置页面使其可以根据你定义的时间间隔刷新自己,以及设置RASC内容等级，等等。 name 属性1、用以说明生成工具（如Microsoft FrontPage 4.0）等；2、向搜索引擎说明你的网页的关键词；3、告诉搜索引擎你的站点的主要内容；4、告诉搜索引擎你的站点的制作的作者；5、 其中的属性说明如下： 设定为all：文件将被检索，且页面上的链接可以被查询； 设定为none：文件将不被检索，且页面上的链接不可以被查询； 设定为index：文件将被检索； 设定为follow：页面上的链接可以被查询； 设定为noindex：文件将不被检索，但页面上的链接可以被查询； 设定为nofollow：文件将不被检索，页面上的链接可以被查询。http-equiv属性1、&lt;meta http-equiv=”Content-Type” contect=”text/html”;charset=gb_2312-80”&gt;和 用以说明主页制作所使用的文字以及语言；又如英文是ISO-8859-1字符集，还有BIG5、utf-8、shift-Jis、Euc、Koi8-2等字符集；2、定时让网页在指定的时间n内，跳转到页面http://yourlink；3、可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式；4、是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；5、cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；6、网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的；7、强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；8、和设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。Open Graph ProtocolMeta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol： The Open Graph Protocol enables any web page to become a rich object in a social graph.+ n3 } 即这种协议可以让网页成为一个“富媒体对象”。用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。","tags":[{"name":"meta","slug":"meta","permalink":"http://yoursite.com/tags/meta/"}]},{"title":"生词记录","date":"2017-05-23T05:34:15.066Z","path":"2017/05/23/生词记录/","text":"assign 分配brackets 括号messy 乱nested 嵌套notation 符号remainder 余proof 证明interpret 解释render 渲染fill text jsonhandlebars jsobject orient 面向对象compiles 编译 syntax 句法 profileduplicate 重复adjacent 邻literal 文字stringfy 字符串interpreted 解释Abbreviation 缩写 plugins 插件 prefixer 前缀 tiny 小 zoom 放大 scale 规模 muted 静音 embed 嵌入profile 个人资料toggled 切换horizontal 水平customize 定制customize 检验plug 插头","tags":[{"name":"生词记录","slug":"生词记录","permalink":"http://yoursite.com/tags/生词记录/"}]},{"title":"模态框","date":"2017-05-23T05:34:15.066Z","path":"2017/05/23/模态框/","text":"激活 Webstorm http://15.idea.lanyus.com/ 1&lt;a href=\"login.html\" data-toggle=\"modal\" data-target=\"#signin-signup-tab\" id=\"signin-button\" class=\"pull-right\"&gt;Sign In&lt;/a&gt; data-toggle指以什么事件触发，常用的如modal,popover,tooltips等，data-target指事件的目标。这段代码的意思就是指将#signin-signup-tab这个Dom元素的内容以模态框的形式展示。","tags":[{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"webstorm 使用","date":"2017-05-23T05:34:15.051Z","path":"2017/05/23/webstorm 使用/","text":"meta:vp + tab!+tabsection*4ta:ctd:n 基础代码 *{ margin: 0; padding: 0; box-sizing: border-box;}a{ text-decoration: none; color: inherit;}ul,ol{ list-style: none;}img{ max-width: 100%;}","tags":[{"name":"webstorm 使用","slug":"webstorm-使用","permalink":"http://yoursite.com/tags/webstorm-使用/"}]},{"title":"js块级作用域","date":"2017-05-23T05:34:15.051Z","path":"2017/05/23/js块级作用域/","text":"1234567891011121314var c=3;function test1()&#123;var c=1; console.log(c); &#125;function test2()&#123; var c=2; console.log(c);&#125;function test3()&#123; console.log(c);&#125;test2();test3(); 输出 1223 一个容易出错的例子 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function buttonInit()&#123; for(var i=1;i&lt;4;i++)&#123; var b=document.getElementById(\"button\"+i); b.addEventListener(\"click\",function()&#123; alert(\"Button\"+i);&#125;,false); &#125;&#125;window.onload=buttonInit;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button id=\"button1\"&gt;Button1&lt;/button&gt;&lt;button id=\"button2\"&gt;Button2&lt;/button&gt;&lt;button id=\"button3\"&gt;Button3&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 当文档加载完毕，给几个按钮注册点击事件，当我们点击按钮时，会弹出什么提示框呢？很容易犯错，对是的，三个按钮都是弹出：”Button4”,你答对了吗？当注册事件结束后，i的值为4，当点击按钮时，事件函数即function(){ alert(“Button”+i);}这个匿名函数中没有i,根据作用域链，所以到buttonInit函数中找，此时i的值为4，所以弹出”button4“。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html   转为  markdown","date":"2017-05-23T05:34:15.018Z","path":"2017/05/23/html   转为  markdown/","text":"123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;title&gt;Marked in the browser&lt;/title&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.6/marked.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"content\"&gt;&lt;/div&gt;&lt;script&gt; document.getElementById('content').innerHTML = marked('# Marked in browser\\n\\nRendered by **marked**. [baidu](http://baidu.com) ');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://typo.sofi.sh/typo.css&quot;&gt;enter code here//中文网页重设与排版","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"meta","date":"2017-05-23T03:35:05.902Z","path":"2017/05/23/filename1/","text":"响应式页面 12&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; // 不要缩放 123img&#123; max-width:100%; &#125; meta是用来在HTML文档中模拟HTTP协议的响应头报文。META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的标记和标记之间，它提供用户不可见的信息。meta标签通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie；它可以用于鉴别作者，设定页面格式，标注内容提要和关键字；还可以设置页面使其可以根据你定义的时间间隔刷新自己,以及设置RASC内容等级，等等。 name 属性1、用以说明生成工具（如Microsoft FrontPage 4.0）等；2、向搜索引擎说明你的网页的关键词；3、告诉搜索引擎你的站点的主要内容；4、告诉搜索引擎你的站点的制作的作者；5、 其中的属性说明如下： 设定为all：文件将被检索，且页面上的链接可以被查询； 设定为none：文件将不被检索，且页面上的链接不可以被查询； 设定为index：文件将被检索； 设定为follow：页面上的链接可以被查询； 设定为noindex：文件将不被检索，但页面上的链接可以被查询； 设定为nofollow：文件将不被检索，页面上的链接可以被查询。http-equiv属性1、&lt;meta http-equiv=”Content-Type” contect=”text/html”;charset=gb_2312-80”&gt;和 用以说明主页制作所使用的文字以及语言；又如英文是ISO-8859-1字符集，还有BIG5、utf-8、shift-Jis、Euc、Koi8-2等字符集；2、定时让网页在指定的时间n内，跳转到页面http://yourlink；3、可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式；4、是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出；5、cookie设定，如果网页过期，存盘的cookie将被删除。需要注意的也是必须使用GMT时间格式；6、网页等级评定，在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的；7、强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用；8、和设定进入和离开页面时的特殊效果，这个功能即FrontPage中的“格式/网页过渡”，不过所加的页面不能够是一个frame页面。Open Graph ProtocolMeta Property=og标签是什么呢?og是一种新的HTTP头部标记，即Open Graph Protocol： The Open Graph Protocol enables any web page to become a rich object in a social graph.+ n3 } 即这种协议可以让网页成为一个“富媒体对象”。用了Meta Property=og标签，就是你同意了网页内容可以被其他社会化网站引用等，目前这种协议被SNS网站如Fackbook、renren采用。SNS已经成为网络上的一大热门应用，优质的内容通过分享在好友间迅速传播。为了提高站外内容的传播效率，2010年F8会议上Facebook公布 了一套开放内容协议(Open Graph Protocol)，任何网页只要遵守该协议，SNS就能从页面上提取最有效的信息并呈现给用户。","tags":[{"name":"meta","slug":"meta","permalink":"http://yoursite.com/tags/meta/"}]},{"title":"webstorm 使用","date":"2017-05-23T03:34:22.140Z","path":"2017/05/23/filename/","text":"meta:vp + tab!+tabsection*4ta:ctd:n 基础代码 *{ margin: 0; padding: 0; box-sizing: border-box;}a{ text-decoration: none; color: inherit;}ul,ol{ list-style: none;}img{ max-width: 100%;}","tags":[{"name":"webstorm 使用","slug":"webstorm-使用","permalink":"http://yoursite.com/tags/webstorm-使用/"}]},{"title":"JavaScript 最新面试题（偏基础）JavaScript 最新面试题（偏基础）","date":"2017-03-19T09:10:59.298Z","path":"2017/03/19/JavaScript 最新面试题/","text":"PS：偏基础，红色是重点、蓝色是扩展；无答案，请自行总结 1、js数据类型有哪些？如何判断一个变量的数据类型？ 怎么判断一个变量是被什么创造出来的？判断js中的数据类型有一下几种方法：typeof、instanceof、 constructor、 prototype、 $.type()/jquery.type(),接下来主要比较一下这几种方法的异同。 先举几个例子： var a = “iamstring.”;var b = 222;var c= [1,2,3];var d = new Date();var e = function(){alert(111);};var f = function(){this.name=”22”;}; 1、最常见的判断方法：typeofalert(typeof a) ————&gt; stringalert(typeof b) ————&gt; numberalert(typeof c) ————&gt; objectalert(typeof d) ————&gt; objectalert(typeof e) ————&gt; functionalert(typeof f) ————&gt; function其中typeof返回的类型都是字符串形式，需注意，例如：alert(typeof a == “string”) ————-&gt; truealert(typeof a == String) —————&gt; false另外typeof 可以判断function的类型；在判断除Object类型的对象时比较方便。 2、判断已知对象类型的方法： instanceofalert(c instanceof Array) —————&gt; truealert(d instanceof Date)alert(f instanceof Function) ————&gt; truealert(f instanceof function) ————&gt; false注意：instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。 3、根据对象的constructor判断： constructoralert(c.constructor === Array) ———-&gt; truealert(d.constructor === Date) ———–&gt; truealert(e.constructor === Function) ——-&gt; true注意： constructor 在类继承时会出错eg： function A(){}; function B(){}; A.prototype = new B(); //A继承自B var aObj = new A(); alert(aobj.constructor === B) ———–&gt; true; alert(aobj.constructor === A) ———–&gt; false;而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报true： alert(aobj instanceof B) —————-&gt; true; alert(aobj instanceof B) —————-&gt; true;言归正传，解决construtor的问题通常是让对象的constructor手动指向自己： aobj.constructor = A; //将自己的类赋值给对象的constructor属性 alert(aobj.constructor === A) ———–&gt; true; alert(aobj.constructor === B) ———–&gt; false; //基类不会报true了; 4、通用但很繁琐的方法： prototypealert(Object.prototype.toString.call(a) === ‘[object String]’) ——-&gt; true;alert(Object.prototype.toString.call(b) === ‘[object Number]’) ——-&gt; true;alert(Object.prototype.toString.call(c) === ‘[object Array]’) ——-&gt; true;alert(Object.prototype.toString.call(d) === ‘[object Date]’) ——-&gt; true;alert(Object.prototype.toString.call(e) === ‘[object Function]’) ——-&gt; true;alert(Object.prototype.toString.call(f) === ‘[object Function]’) ——-&gt; true;大小写不能写错，比较麻烦，但胜在通用。 5、无敌万能的方法：jquery.type()如果对象是undefined或null，则返回相应的“undefined”或“null”。jQuery.type( undefined ) === “undefined”jQuery.type() === “undefined”jQuery.type( window.notDefined ) === “undefined”jQuery.type( null ) === “null”如果对象有一个内部的[[Class]]和一个浏览器的内置对象的 [[Class]] 相同，我们返回相应的 [[Class]] 名字。 (有关此技术的更多细节。 )jQuery.type( true ) === “boolean”jQuery.type( 3 ) === “number”jQuery.type( “test” ) === “string”jQuery.type( function(){} ) === “function”jQuery.type( [] ) === “array”jQuery.type( new Date() ) === “date”jQuery.type( new Error() ) === “error” // as of jQuery 1.9jQuery.type( /test/ ) === “regexp”其他一切都将返回它的类型“object”。通常情况下用typeof 判断就可以了，遇到预知Object类型的情况可以选用instanceof或constructor方法,实在没辙就使用$.type()方法。 2、判断有几种？ 什么是判断嵌套？请举例 switch写法是什么？break有何作用？3、循环有几种？常用的有哪几种？break和continue有何作用？Break: 跳出循环，不再执行循环中的内容Continue: 跳出本次循环，开始下一次循环 4、function是什么？定义一个功能有哪几种写法？return有什么用？函数，是一种方法； return：中断函数，返回调用者期望返回的值一．function 函数名(){}二．var 函数名 = function(){}三．function(){} : 匿名函数 5、什么是函数自运行？怎么写？你什么地方使用过？（循环时怎么保留i的值）不需要外部调用，立即运行(function(){})() 6、什么是递归？有什么用？和循环有什么区别？（自行百度）7、排序算法你知道几种？什么是冒泡排序？什么是快排？（自行百度）快速排序的思想很简单，整个排序过程只需要三步： 在数据集中，选择一个元素作为“基准”(pivot) 所有小于“基准”的元素，都移到“基准”的左边，所有大于“基准”的元素，都移到右边。 对“基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止 。 123456789101112131415var quickSort = function(arr) &#123; if(arr.length &lt;= 1) return arr; // 递归停止条件 // 选取基准值 var pivotIndex = Math.ceil(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; // 基准值 var left = [], right = []; // 如果大于基准值，移到数组right中；小于基准的值，移到数组left中 for(var i=0; i&lt; arr.length; i++) &#123; arr[i] &gt; pivot ? right.push(arr[i]) : left.push(arr[i]); &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 8、列出自己知道的字符串对象的方法，怎么查找？怎么替换？怎么转化为数组？数组怎么转化为字符串9、列出自己知道的时间对象的方法，怎么获取年月日时分秒星期几？怎么获取当前时间戳？怎么定义一个未来时间？（当前时间和倒计时）10、列举出你知道的数组方法，怎么将数组乱序？11、知道数组新增的一些方法吗？foreach、map、reduce等学习连接：http://www.zhangxinxu.com/wordpress/?p=3220 12、怎么使用js跳转页面？13、js获取页面元素的方法有哪几种？怎么创建、删除、克隆、插入元素？14、什么是自定义属性？页面元素添和js对象的自定义属性一样吗？自定义属性一般有什么用？在我们常使用的控件中，我们经常可以自己为元素定义一些属性来达到想要的效果。 例如： 我们想要给按钮设定一个值，这个值对每个按钮都要相同的效果。 12345678910111213141516171819202122&lt;script&gt; window.onload=function()&#123; var aBtn=document.getElementsByTagName(\"input\"); var arr=['A','B','C','D']; for(i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].num=0; aBtn[i].onclick=function()&#123; this.value=arr[this.num]; this.num++; if(this.num===arr.length)&#123; this.num=0; &#125; &#125; &#125; &#125; &lt;/script&gt; &lt;body&gt; &lt;input type=\"button\" value=\"0\" /&gt; &lt;input type=\"button\" value=\"0\" /&gt; &lt;input type=\"button\" value=\"0\" /&gt; &lt;/body&gt; 15、js中常见的事件有哪些？给元素添加事件的形式有哪几种？（3种） 1、在html中，使用onclick属性 2、在javascript中，使用onclick属性 3、在javascipt中，使用addEvenListener()方法 16、什么是事件流？有那几个过程？什么是事件对象？什么是事件源？当onmousemove事件发生时，就会产生一个事件对象，就是程序中的event对象，我们只能在这个匿名函数中访问到这个event对象，在函数外面是访问不到的，同样我们也无法手动创建这个event对象； 如何获取事件对象那？？ var e = event || window.event;这句话就是定义了一个变量来获取事件对象，因为不同的浏览器获取事件对象的方法有点不太一样，IE下是window.event，标准下是event，为了兼容所以写了event || window.event. 事件对象也分为： 鼠标事件对象，键盘事件对象等，顾名思义鼠标事件发生时产生鼠标事件对象，键盘事件发生时产生键盘事件对象；既然是对象，就必然有一些属性方法啥的。 鼠标事件对象上的常用属性： clientX，clientY，screenX，screenY，offsetX，offsetY键盘事件对象上的属性有： keyCode: 用来获取键盘码的;比如空格的键盘是32，回车13等 cltkey: 判断alt键是否被按下，按下是true，反之false Ctrlkey: 判断Ctrlkey键是否被按下，按下是true，反之false Shiftkey : 判断Shiftkey 键是否被按下，按下是true，反之false 说到这里相信大家应该理解“事件对象”了吧！接着说一说事件源。 事件源： 在事件中，当前操作的那个元素就是事件源。比如网页元素中a标签和input都有onclick事件，当点击a发生onclick事件时，事件源就是a标签，当点击input发送onclic事件是，事件源就是input。 如何获取事件源那？？ IE下：window.event.srcElement 标准下：event.target 由此可见，我们是通过事件对象获取到的事件源。 什么是事件流流：用术语说流是对输入输出设备的抽象。以程序的角度说，流是具有方向的数据。 事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。 事件：用户或者浏览器自身执行的某个动作，比如load，click，mousemove等 事件处理程序：相应处理某个事件的函数叫做事件处理函数（也叫做事件侦听器） 理解DOM中的事件流 当浏览器发展到第四代时（IE4和NetscapeCommunicator4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。 IE提出的事件冒泡 事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"click\"&gt;点击&lt;/button&gt; &lt;script&gt; (function()&#123; var btn = document.getElementById(\"click\"); btn.onclick = function()&#123; console.log(\"1. button\"); &#125; document.body.onclick = function()&#123; console.log(\"2. document.body\"); &#125; document.onclick = function()&#123; console.log(\"3. document\"); &#125; window.onclick = function()&#123; console.log(\"4. window\"); &#125; &#125;)() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在代码所示的页面中，如果点击了button，那么这个点击事件会得到如下的结果：![enter description here][1] 也就是说，click事件首先在button元素上发生，然后逐级向上传播。这就是事件冒泡。 netscape提出的事件捕获 事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。比如说刚才的demo，如果是事件捕获的话，事件发生顺序会是刚好与上面相反的。即window,document,document.body,button。 虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。 所以放心的使用事件冒泡，有特殊需要再使用事件捕获即可。 DOM事件流 DOM事件流可以分为下面3个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段![enter description here][2] 事件捕获阶段 也就是说，当事件发生时，首先发生的是事件捕获，为父元素截获事件提供了机会。例如，我把上面的Demo中，window点击事件更改为使用事件捕获模式。 addEventListener最后一个参数，为true则代表使用事件捕获模式，false则表示使用事件冒泡模式。 12345678910111213&lt;script&gt; (function()&#123; var btn = document.getElementById(\"click\"); btn.addEventListener(\"click\",function()&#123; console.log(\"1. button\"); &#125;,true) //省略document.body和document ..... window.addEventListener(\"click\",function()&#123; console.log(\"4. window\"); &#125;,true) &#125;)() &lt;/script&gt; ![enter description here][3]可以看到，点击事件先被父元素截获了，且该函数只在事件捕获阶段起作用。 在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到body后就定停止了。下一个阶段是处于目标阶段，于是事件在button上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。 但是：我们的各大浏览器总是不喜欢按照规范来，IE9，Safari，chrome，firefox及其更高的版本中都会在捕获阶段出发事件对象上的事件，最后导致有两个机会在目标对象上操作事件。 处于目标与事件冒泡阶段 事件到了具体元素时，在具体元素上发生，并且被看成冒泡阶段的一部分。随后，冒泡阶段发生，事件开始冒泡。 阻止事件冒泡 件冒泡过程，是可以被阻止的。防止事件冒泡而带来不必要的错误和困扰。 这个方法就是:stopPropagation() 12345678910111213(function()&#123; var btn = document.getElementById(&quot;click&quot;); btn.addEventListener(&quot;click&quot;,function(event)&#123; console.log(&quot;1. button&quot;); event.stopPropagation(); console.log(&apos;Stop Propagation!&apos;); &#125;,false) //省略document.body和document ..... window.addEventListener(&quot;click&quot;,function()&#123; console.log(&quot;4. window&quot;); &#125;,false)&#125;)() 最后结果是：1.button，Stop Propagation!。通过stopPropagation();阻止了事件的冒泡。 事件处理程序类别 刚刚我们已经讲了事件处理程序就是相应处理某个事假的函数。它可以分为几个类别： html事件处理程序 某个元素支持的某个事件可以用与事件处理程序同名的html特性来指定，该特性的值是能够执行的JavaScript代码,这也是我们最初学js，最开始的方法。 123456789&lt;script&gt; function show()&#123; alert('我被点击了'); &#125;/* 点击后也会弹出 '我被点击了'*/&lt;/script&gt;&lt;input type=\"button\" value=\"点击\" onclick=\"show()\" /&gt; 优点：简单明了，省去获取元素等一系列前提操作 缺点：html代码与js代码高度耦合，不符合分离原则 DOM0级别事件处理函数 DOM0级别事件处理函数，使用 element.on[eventname]=fn的方式给元素添加事件 1234567优点：简单明了，省去获取元素等一系列前提操作缺点：html代码与js代码高度耦合，不符合分离原则DOM0级别事件处理函数DOM0级别事件处理函数，使用 element.on[eventname]=fn的方式给元素添加事件 DOM2级事件处理程序 DOM2级添加了addEventListener（添加事件处理程序）和removeEventListener(移除事件处理程序),也就是我们刚刚讲的上面的DOM2例子。 添加事件处理函数addEventListener 参数1 指定事件名称…click mouseover mouseout参数2 事件处理程序（匿名函数或者有名函数）参数3 true（捕获阶段发生） or false（冒泡阶段发生） 1234567891011&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click'); oBtn.addEventListener('click',function()&#123; alert(this.id)//click this指的是该元素作用域内 &#125;,false) //注意该种方式可以给一个函数添加多个事件处理函数，执行顺序与添加顺序相同 oBtn.addEventListener('click',function()&#123; alert('Hello World')//click &#125;,false) &lt;/script&gt; 移除事件处理函数removeEventListener 如果事件处理函数是有名函数，则可以通过名字来移除，匿名函数无法移除。 12345678910111213&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click');function showId()&#123; alert(this.id);&#125;;function HelloWorld()&#123; alert('HellowWorld');&#125;oBtn.addEventListener(\"click\",showId,false);oBtn.addEventListener(\"click\",HelloWorld,false);oBtn.removeEventListener('click',showId,false)&lt;/script&gt; 最后只能弹出HellowWorld IE事件处理程序attachEvent,detachEventie实现了与dom类似的两个方法，attachEvent（添加），detachEvent（删除） 123 oBtn.attachEvent('onclick',showId);//这时候会报错，因为这里的是在window的作用域内//修改如下oBtn.detachEvent('onclick',showId) ;//点击没有任何反应 Mozilla中： addEventListener的使用方式： target.addEventListener(type, listener, useCapture); target： 文档节点、document、window 或 XMLHttpRequest。type： 字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等。listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。useCapture ：是否使用捕捉，一般用 false 。例如：document.getElementById(“testText”).addEventListener(“keydown”, function (event) { alert(event.keyCode); }, false); IE中： target.attachEvent(type, listener);target： 文档节点、document、window 或 XMLHttpRequest。type： 字符串，事件名称，含“on”，比如“onclick”、“onmouseover”、“onkeydown”等。listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。 例如：document.getElementById(“txt”).attachEvent(“onclick”,function(event){alert(event.keyCode);}); W3C 及 IE 同时支持移除指定的事件, 用途是移除设定的事件, 格式分别如下: W3C格式: removeEventListener(event,function,capture/bubble); Windows IE的格式如下: detachEvent(event,function); target.addEventListener(type, listener, useCapture);target 文档节点、document、window 或 XMLHttpRequest。type 字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等。listener 实现了 EventListener 接口或者是 JavaScript 中的函数。useCapture 是否使用捕捉，看了后面的事件流一节后就明白了，一般用 false事件触发时，会将一个 Event 对象传递给事件处理程序，比如：document.getElementById(“testText”).addEventListener(“keydown”, function (event) { alert(event.keyCode); }, false);适应的浏览器版本不同，同时在使用的过程中要注意attachEvent方法 按钮onclick IE中使用addEventListener方法 按钮click fox中使用两者使用的原理：可对执行的优先级不一样，下面实例讲解如下：attachEvent方法，为某一事件附加其它的处理事件。（不支持Mozilla系列）addEventListener方法 用于 Mozilla系列举例: document.getElementById(“btn”).onclick = method1;document.getElementById(“btn”).onclick = method2;document.getElementById(“btn”).onclick = method3;如果这样写,那么将会只有medhot3被执行写成这样：var btn1Obj = document.getElementById(“btn1”); //object.attachEvent(event,function);btn1Obj.attachEvent(“onclick”,method1);btn1Obj.attachEvent(“onclick”,method2);btn1Obj.attachEvent(“onclick”,method3);执行顺序为method3-&gt;method2-&gt;method1如果是Mozilla系列，并不支持该方法，需要用到addEventListener var btn1Obj = document.getElementById(“btn1”);//element.addEventListener(type,listener,useCapture);btn1Obj.addEventListener(“click”,method1,false);btn1Obj.addEventListener(“click”,method2,false);btn1Obj.addEventListener(“click”,method3,false);执行顺序为method1-&gt;method2-&gt;method3实例：(要注意的是div必须放到js前面才行) 1234567891011121314151617181920212223 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"name1\" style=\"border:1px solid red;padding:10px 10px 10px 10px;\" style=\"border:1px solid red;padding:10px 10px 10px 10px;\"&gt; &lt;div id=\"name2\" style=\"border:1px solid green;padding:10px 10px 10px 10px;\" style=\"border:1px solid green;padding:10px 10px 10px 10px;\"&gt;点击&lt;/div&gt; &lt;/div&gt; &lt;div id=\"info\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt;&lt;!-- var name1=document.getElementById('name1'); //要注意 var name2=document.getElementById('name2'); //要注意 var info=document.getElementById('info'); if(name1.attachEvent)&#123; //对于attachEvent前面的target我们一定要保证不为空 name1.attachEvent('onclick',function () &#123; info.innerHTML += \"红色\" + \"&lt;br&gt;\"; &#125;); name2.attachEvent('onclick',function () &#123; info.innerHTML += \"绿色\" + \"&lt;br&gt;\"; &#125;); &#125;else&#123; name1.addEventListener('click',function () &#123; info.innerHTML += \"红色\" + \"&lt;br&gt;\"; &#125;,false); name2.addEventListener('click',function () &#123; info.innerHTML += \"绿色\" + \"&lt;br&gt;\"; &#125;,false); &#125; // --&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 17、什么是事件委托？原理是什么？（自行举例并测试）有什么好处？事件委托原理：事件冒泡机制。优点：1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。 123456789101112131415161718192021222324252627&lt;ul id=\"ul1\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var oUl1 = document.getElementById('ul1'); myAddEvent(oUl1,'click',function(e)&#123; var e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName === 'LI')&#123; alert(target.innerHTML); target.style.background = 'red'; &#125; &#125;); // 事件绑定封装成js函数 function myAddEvent(obj, ev, fn)&#123; if(obj.attachEvent)&#123; // ie obj.attachEvent('on'+ev, fn); &#125;else&#123; obj.addEventListener(ev, fn, false); &#125; &#125; &lt;/script&gt; 18、怎么给未来元素绑定事件？（刚开始页面上不存在的元素，后续通过js添加） 19、你是怎么理解this的？ 20、什么是异步和同步？简述ajax的流程![enter description here][2] ![enter description here][3] 一、ajax概述 1、Ajax是Asynchronous（[ə’sɪŋkrənəs） JavaScript XML的简写，不是一门新技术，而是对现有技术的综合利用。这一技术能够向服务器请求额外数据而无需刷新页面，带来了更好的用户体验 2、Ajax技术的核心是XMLHttpRequest对象（简称XHR），这是由微软首先引入的一个特性。在XHR出现之前，Ajax式的通信必须借助一些hack手段来实现，大多数是使用隐藏的框架或内嵌框架。 3、XHR为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步的方式从服务器取得更多的信息，意味着用户单击后，可以不必刷新页面也能获取新数据。也就是说可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中 4、虽然Ajax名字中有XML的成分，但是呢，Ajax通信与数据格式无关，这种技术就是无须刷新页面即可从服务器取得数据，但不一定是XML数据 二、操作：原生ajax和jQuery中封装的ajax 1、原生ajax： ajax作用：发送请求（设置请求setRequest） 接收响应(getResponse) A、ajax原生方式发送请求： Ajax中最重要也是最固定的部分就是http请求。 1)建立连接：（IE7及以上版本都支持XMLHttpRequest） 1var xhr = new XMLHttpRequest(); //创建异步请求对象 2)Get请求：格式必须是（url?name1=value1&amp;name2=value2） 12xhr.open(\"get\",\"01-register.php?name=\"+name);//初始化异步get请求xhr.send(null); //与服务器建立连接 3)Post请求 123xhr.open('post','01-XMLHTTPRequest-test.php');//请求报文行xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); /*post请求设置请求头*/xhr.send('name=rose&amp;age=20'); //请求报文体 4)get和post请求的区别： ★get不需要设置请求头，而post需要设置请求头 ★get的数据传递通过url进行，而post的数据在send方法中传递 B、ajax原生方式接收响应： 123456789/*监听服务器的响应*/xhr.onreadystatechange=function()&#123;/*判断当前的响应是否成功 1.服务器做出了响应 2.响应的结果是正确的*/ if(xhr.status==200 &amp;&amp; xhr.readyState==4)&#123; var result=xhr.responseText; console.log(result); //输出从服务器中获取到的数据 //接下来就可以对数据进行相应的处理了 &#125; &#125;; C、处理响应数据： 1234567891011121314151617181920/*监听*/xhr.onreadystatechange=function()&#123;if(xhr.status==200 &amp;&amp; xhr.readyState==4)&#123; /*判断状态*/var result;/*获取响应报文中的Content-Type*/var ct=xhr.getResponseHeader(\"Content-Type\");/*判断Content-Type,进行数据的解析*/if(ct.indexOf(\"xml\") != -1)&#123;result=xhr.responseXML;&#125;else if(ct.indexOf(\"json\") !=-1)&#123;result=JSON.parse(xhr.responseText);&#125;else&#123;result=xhr.responseText;&#125;/*调用回调函数--委托--代理*/success &amp;&amp; success(result);&#125;&#125;; jQuery中封装的ajax 123456789$.ajax(&#123;type: 请求方式(get/post),url: \"register.php\",data: 发送请求数据,beforeSend:function()&#123;返回false可以取消本次ajax请求&#125;,success:function(result)&#123; 成功响应后调用 &#125;,error:function(err)&#123; 错误响应时调用 &#125;,complete:function()&#123; 响应完成时调用(包括成功和失败) &#125;&#125;); jQuery中提供了专门的方法来序列化表单： 1$('form').serialize(): //序列化表单(即格式化key=val &amp; key=val); 三、响应 我们需要监听服务器的响应状态，然后对从服务器中获取的数据做相应的处理。 1) onreadystatechange是JavaScript事件中的一种，用于监听XMLHttpRequest的状态 2) readystate：响应状态，返回XMLHTTP请求的当前状态 readyState 状态 状态说明 (0)未初始化 此阶段确认XMLHttpRequest对象是否创建，并为调用open()方法进行未初始化作好准备。值为0表示对象已经存在，否则浏览器会报错－－对象不存在。 (1)载入 此阶段对XMLHttpRequest对象进行初始化，即调用open()方法，根据参数(method,url,true)完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。 (2)载入完成 此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。 (3)交互 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。 (4)完成 此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。 web服务器响应码401 UNAUTHORIZED 表示您必须有一个正确的用户名称及密码才能得到对方网页（unauthorized site）的使用权，例如浏览一些收费网页时就会出现这个信息。 403 FORBIDDEN 可能是因为您未在对方网站注册，一般情况下可在网上进行即时注册，但一些完全”封闭”的网站都会产生以上的信息。 404 NOT FOUND 最常见的出错信息，其实这是因为您的WWW浏览器不能找到您所要的文件（即网页），该文件可能被移到别的地方去了、或者根本就不复存在。 409 Fire flood and Pestilence 无意义。 解决办法：重新连接。 500 SERVER ERROR 这个信息通常是对方网页程序设计错误而产生的，您等待对方网页纠正错误后再上吧。 503 SERVICE UNAVAILABLE 这个信息表示不能连上对方网站、是因为网络线路非常繁忙。过一会儿（比如三分钟后）再试试吧。 21、什么是同源策略？什么是跨域？怎么解决跨域？jsonp的原理是什么？jsonp是如何得到后台返回的数据的？22、什么是面向对象和面向过程？对象中什么是属性？什么是方法？ 23、怎么获取person对象的age属性？有几种写法？遍历一个JS对象中的所有属性 12345&lt;script&gt;var obj = &#123;a:1,b:2,c:3&#125;for(var s in obj)alert(obj[s]);&lt;/script&gt; 24、什么是类？js怎么定义类？什么是原型？有什么用？javascript的方法可以分为三类： 类方法对象方法原型方法 12345678910111213141516171819202122232425262728function People(name)&#123; this.name=name; //对象方法 this.Introduce=function()&#123; alert(\"My name is \"+this.name); &#125;&#125;//类方法People.Run=function()&#123; alert(\"I can run\");&#125;//原型方法People.prototype.IntroduceChinese=function()&#123; alert(\"我的名字是\"+this.name);&#125;//测试var p1=new People(\"Windking\");p1.Introduce();People.Run();p1.IntroduceChinese(); 25、什么是原型链？实现继承的方式有几种？ 26、call和apply是什么？有什么用 27、什么是插件？自己封装过插件吗？","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"节点测试","date":"2017-03-17T07:35:55.741Z","path":"2017/03/17/节点测试/","text":"####首先了解一下DOM中有三大节点，分别是 元素节点，文本节点，属性节点 元素节点：构成了DOM的基础。文档结构中，是根元素，代表整个文档，其他的还有,,,等等。元素节点之间可以相互包含(当然遵循一定的规则) 文本节点：包含在元素节点中。 属性节点：元素都可以包含一些属性，属性的作用是对元素做出更具体的描述，比如id,name之类的。 以下面的demo为例： &lt;script&gt; window.onload = function(){ var element = document.getElementById(&quot;span&quot;); var text = element.firstChild; var property=document.getElementById(&quot;span&quot;).getAttributeNode(&quot;id&quot;); } &lt;/script&gt; &lt;body&gt; &lt;div&gt; &lt;span id=&quot;span&quot;&gt;文本节点&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; (一)nodeName 属性含有某个节点的名称。元素节点的 nodeName 是标签名称（返回的名称是大写的） 属性节点的 nodeName 是属性名称（返回的名称是大写的） 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 注释：nodeName 所包含的 XML 元素的标签名称永远是大写的 alert(“这是元素节点的返回值：”+ element.nodeName);//返回的标签名SPAN,注意是大写的alert(“这是文本节点的返回值：”+ text.nodeName);//返回的#textalert(“这是属性节点的返回值：”+ property.nodeName);//返回的是属性名，这里是id (二)nodeValue对于文本节点，nodeValue 属性包含文本。 对于属性节点，nodeValue 属性包含属性值。 nodeValue 属性对于文档节点和元素节点是不可用的。 alert(“这是元素节点的返回值：”+ element.nodeValue);//本身就没有意义，这里是试验下的，返回的是nullalert(“这是文本节点的返回值：”+ text.nodeValue);//返回的是文本值 文本节点alert(“这是属性节点的返回值：”+ property.nodeValue);//返回的是属性值，这里是id的属性值span (三)nodeTypenodeType 属性可返回节点的类型。 我们常用的3中类型：nodeType == 1 ： 元素节点nodeType == 2 ： 属性节点nodeType == 3 ： 文本节点 注释 comments 8 文档 document 9 alert(“这是元素节点的返回值：”+ element.nodeType);//元素节点返回1 alert(“这是文本节点的返回值：”+ text.nodeType);//文本节点返回3 alert(“这是属性节点的返回值：”+ property.nodeType);//属性节点返回2","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript 最新面试题（偏基础）JavaScript 最新面试题（偏基础）","date":"2017-03-17T03:27:24.633Z","path":"2017/03/17/JavaScript 最新面试题（偏基础）JavaScript 最新面试题（偏基础）/","text":"PS：偏基础，红色是重点、蓝色是扩展；无答案，请自行总结 1、js数据类型有哪些？如何判断一个变量的数据类型？ 怎么判断一个变量是被什么创造出来的？判断js中的数据类型有一下几种方法：typeof、instanceof、 constructor、 prototype、 $.type()/jquery.type(),接下来主要比较一下这几种方法的异同。 先举几个例子： var a = “iamstring.”;var b = 222;var c= [1,2,3];var d = new Date();var e = function(){alert(111);};var f = function(){this.name=”22”;}; 1、最常见的判断方法：typeofalert(typeof a) ————&gt; stringalert(typeof b) ————&gt; numberalert(typeof c) ————&gt; objectalert(typeof d) ————&gt; objectalert(typeof e) ————&gt; functionalert(typeof f) ————&gt; function其中typeof返回的类型都是字符串形式，需注意，例如：alert(typeof a == “string”) ————-&gt; truealert(typeof a == String) —————&gt; false另外typeof 可以判断function的类型；在判断除Object类型的对象时比较方便。 2、判断已知对象类型的方法： instanceofalert(c instanceof Array) —————&gt; truealert(d instanceof Date)alert(f instanceof Function) ————&gt; truealert(f instanceof function) ————&gt; false注意：instanceof 后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。 3、根据对象的constructor判断： constructoralert(c.constructor === Array) ———-&gt; truealert(d.constructor === Date) ———–&gt; truealert(e.constructor === Function) ——-&gt; true注意： constructor 在类继承时会出错eg： function A(){}; function B(){}; A.prototype = new B(); //A继承自B var aObj = new A(); alert(aobj.constructor === B) ———–&gt; true; alert(aobj.constructor === A) ———–&gt; false;而instanceof方法不会出现该问题，对象直接继承和间接继承的都会报true： alert(aobj instanceof B) —————-&gt; true; alert(aobj instanceof B) —————-&gt; true;言归正传，解决construtor的问题通常是让对象的constructor手动指向自己： aobj.constructor = A; //将自己的类赋值给对象的constructor属性 alert(aobj.constructor === A) ———–&gt; true; alert(aobj.constructor === B) ———–&gt; false; //基类不会报true了; 4、通用但很繁琐的方法： prototypealert(Object.prototype.toString.call(a) === ‘[object String]’) ——-&gt; true;alert(Object.prototype.toString.call(b) === ‘[object Number]’) ——-&gt; true;alert(Object.prototype.toString.call(c) === ‘[object Array]’) ——-&gt; true;alert(Object.prototype.toString.call(d) === ‘[object Date]’) ——-&gt; true;alert(Object.prototype.toString.call(e) === ‘[object Function]’) ——-&gt; true;alert(Object.prototype.toString.call(f) === ‘[object Function]’) ——-&gt; true;大小写不能写错，比较麻烦，但胜在通用。 5、无敌万能的方法：jquery.type()如果对象是undefined或null，则返回相应的“undefined”或“null”。jQuery.type( undefined ) === “undefined”jQuery.type() === “undefined”jQuery.type( window.notDefined ) === “undefined”jQuery.type( null ) === “null”如果对象有一个内部的[[Class]]和一个浏览器的内置对象的 [[Class]] 相同，我们返回相应的 [[Class]] 名字。 (有关此技术的更多细节。 )jQuery.type( true ) === “boolean”jQuery.type( 3 ) === “number”jQuery.type( “test” ) === “string”jQuery.type( function(){} ) === “function”jQuery.type( [] ) === “array”jQuery.type( new Date() ) === “date”jQuery.type( new Error() ) === “error” // as of jQuery 1.9jQuery.type( /test/ ) === “regexp”其他一切都将返回它的类型“object”。通常情况下用typeof 判断就可以了，遇到预知Object类型的情况可以选用instanceof或constructor方法,实在没辙就使用$.type()方法。 2、判断有几种？ 什么是判断嵌套？请举例 switch写法是什么？break有何作用？3、循环有几种？常用的有哪几种？break和continue有何作用？Break: 跳出循环，不再执行循环中的内容Continue: 跳出本次循环，开始下一次循环 4、function是什么？定义一个功能有哪几种写法？return有什么用？函数，是一种方法； return：中断函数，返回调用者期望返回的值一．function 函数名(){}二．var 函数名 = function(){}三．function(){} : 匿名函数 5、什么是函数自运行？怎么写？你什么地方使用过？（循环时怎么保留i的值）不需要外部调用，立即运行(function(){})() 6、什么是递归？有什么用？和循环有什么区别？（自行百度）7、排序算法你知道几种？什么是冒泡排序？什么是快排？（自行百度）快速排序的思想很简单，整个排序过程只需要三步： 在数据集中，选择一个元素作为“基准”(pivot) 所有小于“基准”的元素，都移到“基准”的左边，所有大于“基准”的元素，都移到右边。 对“基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止 。 123456789101112131415var quickSort = function(arr) &#123; if(arr.length &lt;= 1) return arr; // 递归停止条件 // 选取基准值 var pivotIndex = Math.ceil(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; // 基准值 var left = [], right = []; // 如果大于基准值，移到数组right中；小于基准的值，移到数组left中 for(var i=0; i&lt; arr.length; i++) &#123; arr[i] &gt; pivot ? right.push(arr[i]) : left.push(arr[i]); &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;; 8、列出自己知道的字符串对象的方法，怎么查找？怎么替换？怎么转化为数组？数组怎么转化为字符串9、列出自己知道的时间对象的方法，怎么获取年月日时分秒星期几？怎么获取当前时间戳？怎么定义一个未来时间？（当前时间和倒计时）10、列举出你知道的数组方法，怎么将数组乱序？11、知道数组新增的一些方法吗？foreach、map、reduce等学习连接：http://www.zhangxinxu.com/wordpress/?p=3220 12、怎么使用js跳转页面？13、js获取页面元素的方法有哪几种？怎么创建、删除、克隆、插入元素？14、什么是自定义属性？页面元素添和js对象的自定义属性一样吗？自定义属性一般有什么用？在我们常使用的控件中，我们经常可以自己为元素定义一些属性来达到想要的效果。 例如： 我们想要给按钮设定一个值，这个值对每个按钮都要相同的效果。 12345678910111213141516171819202122&lt;script&gt; window.onload=function()&#123; var aBtn=document.getElementsByTagName(\"input\"); var arr=['A','B','C','D']; for(i=0;i&lt;aBtn.length;i++)&#123; aBtn[i].num=0; aBtn[i].onclick=function()&#123; this.value=arr[this.num]; this.num++; if(this.num===arr.length)&#123; this.num=0; &#125; &#125; &#125; &#125; &lt;/script&gt; &lt;body&gt; &lt;input type=\"button\" value=\"0\" /&gt; &lt;input type=\"button\" value=\"0\" /&gt; &lt;input type=\"button\" value=\"0\" /&gt; &lt;/body&gt; 15、js中常见的事件有哪些？给元素添加事件的形式有哪几种？（3种） 1、在html中，使用onclick属性 2、在javascript中，使用onclick属性 3、在javascipt中，使用addEvenListener()方法 16、什么是事件流？有那几个过程？什么是事件对象？什么是事件源？当onmousemove事件发生时，就会产生一个事件对象，就是程序中的event对象，我们只能在这个匿名函数中访问到这个event对象，在函数外面是访问不到的，同样我们也无法手动创建这个event对象； 如何获取事件对象那？？ var e = event || window.event;这句话就是定义了一个变量来获取事件对象，因为不同的浏览器获取事件对象的方法有点不太一样，IE下是window.event，标准下是event，为了兼容所以写了event || window.event. 事件对象也分为： 鼠标事件对象，键盘事件对象等，顾名思义鼠标事件发生时产生鼠标事件对象，键盘事件发生时产生键盘事件对象；既然是对象，就必然有一些属性方法啥的。 鼠标事件对象上的常用属性： clientX，clientY，screenX，screenY，offsetX，offsetY键盘事件对象上的属性有： keyCode: 用来获取键盘码的;比如空格的键盘是32，回车13等 cltkey: 判断alt键是否被按下，按下是true，反之false Ctrlkey: 判断Ctrlkey键是否被按下，按下是true，反之false Shiftkey : 判断Shiftkey 键是否被按下，按下是true，反之false 说到这里相信大家应该理解“事件对象”了吧！接着说一说事件源。 事件源： 在事件中，当前操作的那个元素就是事件源。比如网页元素中a标签和input都有onclick事件，当点击a发生onclick事件时，事件源就是a标签，当点击input发送onclic事件是，事件源就是input。 如何获取事件源那？？ IE下：window.event.srcElement 标准下：event.target 由此可见，我们是通过事件对象获取到的事件源。 什么是事件流流：用术语说流是对输入输出设备的抽象。以程序的角度说，流是具有方向的数据。 事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。 事件：用户或者浏览器自身执行的某个动作，比如load，click，mousemove等 事件处理程序：相应处理某个事件的函数叫做事件处理函数（也叫做事件侦听器） 理解DOM中的事件流 当浏览器发展到第四代时（IE4和NetscapeCommunicator4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。 IE提出的事件冒泡 事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"click\"&gt;点击&lt;/button&gt; &lt;script&gt; (function()&#123; var btn = document.getElementById(\"click\"); btn.onclick = function()&#123; console.log(\"1. button\"); &#125; document.body.onclick = function()&#123; console.log(\"2. document.body\"); &#125; document.onclick = function()&#123; console.log(\"3. document\"); &#125; window.onclick = function()&#123; console.log(\"4. window\"); &#125; &#125;)() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在代码所示的页面中，如果点击了button，那么这个点击事件会得到如下的结果：![enter description here][1] 也就是说，click事件首先在button元素上发生，然后逐级向上传播。这就是事件冒泡。 netscape提出的事件捕获 事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。比如说刚才的demo，如果是事件捕获的话，事件发生顺序会是刚好与上面相反的。即window,document,document.body,button。 虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。 所以放心的使用事件冒泡，有特殊需要再使用事件捕获即可。 DOM事件流 DOM事件流可以分为下面3个阶段： 事件捕获阶段 处于目标阶段 事件冒泡阶段![enter description here][2] 事件捕获阶段 也就是说，当事件发生时，首先发生的是事件捕获，为父元素截获事件提供了机会。例如，我把上面的Demo中，window点击事件更改为使用事件捕获模式。 addEventListener最后一个参数，为true则代表使用事件捕获模式，false则表示使用事件冒泡模式。 12345678910111213&lt;script&gt; (function()&#123; var btn = document.getElementById(\"click\"); btn.addEventListener(\"click\",function()&#123; console.log(\"1. button\"); &#125;,true) //省略document.body和document ..... window.addEventListener(\"click\",function()&#123; console.log(\"4. window\"); &#125;,true) &#125;)() &lt;/script&gt; ![enter description here][3]可以看到，点击事件先被父元素截获了，且该函数只在事件捕获阶段起作用。 在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到body后就定停止了。下一个阶段是处于目标阶段，于是事件在button上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。 但是：我们的各大浏览器总是不喜欢按照规范来，IE9，Safari，chrome，firefox及其更高的版本中都会在捕获阶段出发事件对象上的事件，最后导致有两个机会在目标对象上操作事件。 处于目标与事件冒泡阶段 事件到了具体元素时，在具体元素上发生，并且被看成冒泡阶段的一部分。随后，冒泡阶段发生，事件开始冒泡。 阻止事件冒泡 件冒泡过程，是可以被阻止的。防止事件冒泡而带来不必要的错误和困扰。 这个方法就是:stopPropagation() 12345678910111213(function()&#123; var btn = document.getElementById(&quot;click&quot;); btn.addEventListener(&quot;click&quot;,function(event)&#123; console.log(&quot;1. button&quot;); event.stopPropagation(); console.log(&apos;Stop Propagation!&apos;); &#125;,false) //省略document.body和document ..... window.addEventListener(&quot;click&quot;,function()&#123; console.log(&quot;4. window&quot;); &#125;,false)&#125;)() 最后结果是：1.button，Stop Propagation!。通过stopPropagation();阻止了事件的冒泡。 事件处理程序类别 刚刚我们已经讲了事件处理程序就是相应处理某个事假的函数。它可以分为几个类别： html事件处理程序 某个元素支持的某个事件可以用与事件处理程序同名的html特性来指定，该特性的值是能够执行的JavaScript代码,这也是我们最初学js，最开始的方法。 123456789&lt;script&gt; function show()&#123; alert('我被点击了'); &#125;/* 点击后也会弹出 '我被点击了'*/&lt;/script&gt;&lt;input type=\"button\" value=\"点击\" onclick=\"show()\" /&gt; 优点：简单明了，省去获取元素等一系列前提操作 缺点：html代码与js代码高度耦合，不符合分离原则 DOM0级别事件处理函数 DOM0级别事件处理函数，使用 element.on[eventname]=fn的方式给元素添加事件 1234567优点：简单明了，省去获取元素等一系列前提操作缺点：html代码与js代码高度耦合，不符合分离原则DOM0级别事件处理函数DOM0级别事件处理函数，使用 element.on[eventname]=fn的方式给元素添加事件 DOM2级事件处理程序 DOM2级添加了addEventListener（添加事件处理程序）和removeEventListener(移除事件处理程序),也就是我们刚刚讲的上面的DOM2例子。 添加事件处理函数addEventListener 参数1 指定事件名称…click mouseover mouseout参数2 事件处理程序（匿名函数或者有名函数）参数3 true（捕获阶段发生） or false（冒泡阶段发生） 1234567891011&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click'); oBtn.addEventListener('click',function()&#123; alert(this.id)//click this指的是该元素作用域内 &#125;,false) //注意该种方式可以给一个函数添加多个事件处理函数，执行顺序与添加顺序相同 oBtn.addEventListener('click',function()&#123; alert('Hello World')//click &#125;,false) &lt;/script&gt; 移除事件处理函数removeEventListener 如果事件处理函数是有名函数，则可以通过名字来移除，匿名函数无法移除。 12345678910111213&lt;input type=\"button\" value=\"点击\" id=\"click\" /&gt;&lt;script&gt; var oBtn=document.getElementById('click');function showId()&#123; alert(this.id);&#125;;function HelloWorld()&#123; alert('HellowWorld');&#125;oBtn.addEventListener(\"click\",showId,false);oBtn.addEventListener(\"click\",HelloWorld,false);oBtn.removeEventListener('click',showId,false)&lt;/script&gt; 最后只能弹出HellowWorld IE事件处理程序attachEvent,detachEventie实现了与dom类似的两个方法，attachEvent（添加），detachEvent（删除） 123 oBtn.attachEvent('onclick',showId);//这时候会报错，因为这里的是在window的作用域内//修改如下oBtn.detachEvent('onclick',showId) ;//点击没有任何反应 Mozilla中： addEventListener的使用方式： target.addEventListener(type, listener, useCapture); target： 文档节点、document、window 或 XMLHttpRequest。type： 字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等。listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。useCapture ：是否使用捕捉，一般用 false 。例如：document.getElementById(“testText”).addEventListener(“keydown”, function (event) { alert(event.keyCode); }, false); IE中： target.attachEvent(type, listener);target： 文档节点、document、window 或 XMLHttpRequest。type： 字符串，事件名称，含“on”，比如“onclick”、“onmouseover”、“onkeydown”等。listener ：实现了 EventListener 接口或者是 JavaScript 中的函数。 例如：document.getElementById(“txt”).attachEvent(“onclick”,function(event){alert(event.keyCode);}); W3C 及 IE 同时支持移除指定的事件, 用途是移除设定的事件, 格式分别如下: W3C格式: removeEventListener(event,function,capture/bubble); Windows IE的格式如下: detachEvent(event,function); target.addEventListener(type, listener, useCapture);target 文档节点、document、window 或 XMLHttpRequest。type 字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等。listener 实现了 EventListener 接口或者是 JavaScript 中的函数。useCapture 是否使用捕捉，看了后面的事件流一节后就明白了，一般用 false事件触发时，会将一个 Event 对象传递给事件处理程序，比如：document.getElementById(“testText”).addEventListener(“keydown”, function (event) { alert(event.keyCode); }, false);适应的浏览器版本不同，同时在使用的过程中要注意attachEvent方法 按钮onclick IE中使用addEventListener方法 按钮click fox中使用两者使用的原理：可对执行的优先级不一样，下面实例讲解如下：attachEvent方法，为某一事件附加其它的处理事件。（不支持Mozilla系列）addEventListener方法 用于 Mozilla系列举例: document.getElementById(“btn”).onclick = method1;document.getElementById(“btn”).onclick = method2;document.getElementById(“btn”).onclick = method3;如果这样写,那么将会只有medhot3被执行写成这样：var btn1Obj = document.getElementById(“btn1”); //object.attachEvent(event,function);btn1Obj.attachEvent(“onclick”,method1);btn1Obj.attachEvent(“onclick”,method2);btn1Obj.attachEvent(“onclick”,method3);执行顺序为method3-&gt;method2-&gt;method1如果是Mozilla系列，并不支持该方法，需要用到addEventListener var btn1Obj = document.getElementById(“btn1”);//element.addEventListener(type,listener,useCapture);btn1Obj.addEventListener(“click”,method1,false);btn1Obj.addEventListener(“click”,method2,false);btn1Obj.addEventListener(“click”,method3,false);执行顺序为method1-&gt;method2-&gt;method3实例：(要注意的是div必须放到js前面才行) 1234567891011121314151617181920212223 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"name1\" style=\"border:1px solid red;padding:10px 10px 10px 10px;\" style=\"border:1px solid red;padding:10px 10px 10px 10px;\"&gt; &lt;div id=\"name2\" style=\"border:1px solid green;padding:10px 10px 10px 10px;\" style=\"border:1px solid green;padding:10px 10px 10px 10px;\"&gt;点击&lt;/div&gt; &lt;/div&gt; &lt;div id=\"info\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt;&lt;!-- var name1=document.getElementById('name1'); //要注意 var name2=document.getElementById('name2'); //要注意 var info=document.getElementById('info'); if(name1.attachEvent)&#123; //对于attachEvent前面的target我们一定要保证不为空 name1.attachEvent('onclick',function () &#123; info.innerHTML += \"红色\" + \"&lt;br&gt;\"; &#125;); name2.attachEvent('onclick',function () &#123; info.innerHTML += \"绿色\" + \"&lt;br&gt;\"; &#125;); &#125;else&#123; name1.addEventListener('click',function () &#123; info.innerHTML += \"红色\" + \"&lt;br&gt;\"; &#125;,false); name2.addEventListener('click',function () &#123; info.innerHTML += \"绿色\" + \"&lt;br&gt;\"; &#125;,false); &#125; // --&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 17、什么是事件委托？原理是什么？（自行举例并测试）有什么好处？事件委托原理：事件冒泡机制。优点：1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。 123456789101112131415161718192021222324252627&lt;ul id=\"ul1\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var oUl1 = document.getElementById('ul1'); myAddEvent(oUl1,'click',function(e)&#123; var e = e || window.event; var target = e.target || e.srcElement; if(target.nodeName === 'LI')&#123; alert(target.innerHTML); target.style.background = 'red'; &#125; &#125;); // 事件绑定封装成js函数 function myAddEvent(obj, ev, fn)&#123; if(obj.attachEvent)&#123; // ie obj.attachEvent('on'+ev, fn); &#125;else&#123; obj.addEventListener(ev, fn, false); &#125; &#125; &lt;/script&gt; 18、怎么给未来元素绑定事件？（刚开始页面上不存在的元素，后续通过js添加） 19、你是怎么理解this的？ 20、什么是异步和同步？简述ajax的流程![enter description here][2] ![enter description here][3] 一、ajax概述 1、Ajax是Asynchronous（[ə’sɪŋkrənəs） JavaScript XML的简写，不是一门新技术，而是对现有技术的综合利用。这一技术能够向服务器请求额外数据而无需刷新页面，带来了更好的用户体验 2、Ajax技术的核心是XMLHttpRequest对象（简称XHR），这是由微软首先引入的一个特性。在XHR出现之前，Ajax式的通信必须借助一些hack手段来实现，大多数是使用隐藏的框架或内嵌框架。 3、XHR为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步的方式从服务器取得更多的信息，意味着用户单击后，可以不必刷新页面也能获取新数据。也就是说可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中 4、虽然Ajax名字中有XML的成分，但是呢，Ajax通信与数据格式无关，这种技术就是无须刷新页面即可从服务器取得数据，但不一定是XML数据 二、操作：原生ajax和jQuery中封装的ajax 1、原生ajax： ajax作用：发送请求（设置请求setRequest） 接收响应(getResponse) A、ajax原生方式发送请求： Ajax中最重要也是最固定的部分就是http请求。 1)建立连接：（IE7及以上版本都支持XMLHttpRequest） 1var xhr = new XMLHttpRequest(); //创建异步请求对象 2)Get请求：格式必须是（url?name1=value1&amp;name2=value2） 12xhr.open(\"get\",\"01-register.php?name=\"+name);//初始化异步get请求xhr.send(null); //与服务器建立连接 3)Post请求 123xhr.open('post','01-XMLHTTPRequest-test.php');//请求报文行xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); /*post请求设置请求头*/xhr.send('name=rose&amp;age=20'); //请求报文体 4)get和post请求的区别： ★get不需要设置请求头，而post需要设置请求头 ★get的数据传递通过url进行，而post的数据在send方法中传递 B、ajax原生方式接收响应： 123456789/*监听服务器的响应*/xhr.onreadystatechange=function()&#123;/*判断当前的响应是否成功 1.服务器做出了响应 2.响应的结果是正确的*/ if(xhr.status==200 &amp;&amp; xhr.readyState==4)&#123; var result=xhr.responseText; console.log(result); //输出从服务器中获取到的数据 //接下来就可以对数据进行相应的处理了 &#125; &#125;; C、处理响应数据： 1234567891011121314151617181920/*监听*/xhr.onreadystatechange=function()&#123;if(xhr.status==200 &amp;&amp; xhr.readyState==4)&#123; /*判断状态*/var result;/*获取响应报文中的Content-Type*/var ct=xhr.getResponseHeader(\"Content-Type\");/*判断Content-Type,进行数据的解析*/if(ct.indexOf(\"xml\") != -1)&#123;result=xhr.responseXML;&#125;else if(ct.indexOf(\"json\") !=-1)&#123;result=JSON.parse(xhr.responseText);&#125;else&#123;result=xhr.responseText;&#125;/*调用回调函数--委托--代理*/success &amp;&amp; success(result);&#125;&#125;; jQuery中封装的ajax 123456789$.ajax(&#123;type: 请求方式(get/post),url: \"register.php\",data: 发送请求数据,beforeSend:function()&#123;返回false可以取消本次ajax请求&#125;,success:function(result)&#123; 成功响应后调用 &#125;,error:function(err)&#123; 错误响应时调用 &#125;,complete:function()&#123; 响应完成时调用(包括成功和失败) &#125;&#125;); jQuery中提供了专门的方法来序列化表单： 1$('form').serialize(): //序列化表单(即格式化key=val &amp; key=val); 三、响应 我们需要监听服务器的响应状态，然后对从服务器中获取的数据做相应的处理。 1) onreadystatechange是JavaScript事件中的一种，用于监听XMLHttpRequest的状态 2) readystate：响应状态，返回XMLHTTP请求的当前状态 readyState 状态 状态说明 (0)未初始化 此阶段确认XMLHttpRequest对象是否创建，并为调用open()方法进行未初始化作好准备。值为0表示对象已经存在，否则浏览器会报错－－对象不存在。 (1)载入 此阶段对XMLHttpRequest对象进行初始化，即调用open()方法，根据参数(method,url,true)完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。 (2)载入完成 此阶段接收服务器端的响应数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示已经接收完全部响应数据。并为下一阶段对数据解析作好准备。 (3)交互 此阶段解析接收到的服务器端响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。状态3表示正在解析数据。 (4)完成 此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。 web服务器响应码401 UNAUTHORIZED 表示您必须有一个正确的用户名称及密码才能得到对方网页（unauthorized site）的使用权，例如浏览一些收费网页时就会出现这个信息。 403 FORBIDDEN 可能是因为您未在对方网站注册，一般情况下可在网上进行即时注册，但一些完全”封闭”的网站都会产生以上的信息。 404 NOT FOUND 最常见的出错信息，其实这是因为您的WWW浏览器不能找到您所要的文件（即网页），该文件可能被移到别的地方去了、或者根本就不复存在。 409 Fire flood and Pestilence 无意义。 解决办法：重新连接。 500 SERVER ERROR 这个信息通常是对方网页程序设计错误而产生的，您等待对方网页纠正错误后再上吧。 503 SERVICE UNAVAILABLE 这个信息表示不能连上对方网站、是因为网络线路非常繁忙。过一会儿（比如三分钟后）再试试吧。 21、什么是同源策略？什么是跨域？怎么解决跨域？jsonp的原理是什么？jsonp是如何得到后台返回的数据的？22、什么是面向对象和面向过程？对象中什么是属性？什么是方法？ 23、怎么获取person对象的age属性？有几种写法？遍历一个JS对象中的所有属性 12345&lt;script&gt;var obj = &#123;a:1,b:2,c:3&#125;for(var s in obj)alert(obj[s]);&lt;/script&gt; 24、什么是类？js怎么定义类？什么是原型？有什么用？javascript的方法可以分为三类： 类方法对象方法原型方法 12345678910111213141516171819202122232425262728function People(name)&#123; this.name=name; //对象方法 this.Introduce=function()&#123; alert(\"My name is \"+this.name); &#125;&#125;//类方法People.Run=function()&#123; alert(\"I can run\");&#125;//原型方法People.prototype.IntroduceChinese=function()&#123; alert(\"我的名字是\"+this.name);&#125;//测试var p1=new People(\"Windking\");p1.Introduce();People.Run();p1.IntroduceChinese(); 25、什么是原型链？实现继承的方式有几种？ 26、call和apply是什么？有什么用 27、什么是插件？自己封装过插件吗？","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"关于异步","date":"2017-03-16T08:00:10.898Z","path":"2017/03/16/关于异步/","text":"异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。 异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 阻塞 / 非阻塞描述的是函数，指访问某个函数时是否会阻塞线程(block，线程进入阻塞状态)。 同步 / 异步描述的是执行IO操作的主体是谁，同步是由用户进程自己去执行最终的IO操作。异步是用户进程自己不关系实际IO操作的过程，只需要由内核在IO完成后通知它既可，由内核进程来执行最终的IO操作。","tags":[{"name":"Node.Js","slug":"Node-Js","permalink":"http://yoursite.com/tags/Node-Js/"}]},{"title":"CSS3（一）","date":"2017-03-16T07:59:16.446Z","path":"2017/03/16/CSS3（一）/","text":"css标准流display:inline-block 在CSS中，块级对象元素会单独占一行显示，多个block元素会各自新起一行，并且可以设置width,height属性；而内联对象元素前后不会产生换行，一系列inline元素都在一行内显示，直到该行排满，对inline元素设置width,height属性无效。我们有个时候既希望元素具有宽度高度特性，又具有同行特性，这个时候我们可以使用inline-block。在CSS中通过display:inline-block对一个对象指定inline-block属性，简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 不兼容——在IE下实现display:inline-block效果的两种方法：1、先用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（原理：这是IE的一个经典bug，如果先定义了display:inline-block，然后再设置display回inline或block，layout不会消失）（暂时理解为布局不会混乱），代码如下：div {display:inline-block;}div {display:inline;} 2、直接让块元素设置为内联对象(display:inline)，然后通过zoom:1触发块元素的layout，代码如下：div {display:inline; zoom:1;} 子绝父相的定位（常用）&lt;style&gt; div {font-size: 15px;color: #fff;} .test1{width: 400px;height: 400px;background: #234;position:relative;} .test2 {width: 300px;height: 300px;background: #345; position: absolute; left: 40px;top: 40px; } .test{ width: 500px;height: 500px;background: #123; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;test1&quot;&gt; test1 &lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;test&quot;&gt; test &lt;/div&gt; &lt;/body&gt; 记一个学习浮动的漏洞对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。 inline-block和float的区别虽然设置浮动跟设置inline-block有些特征类似，但两者的区别还是非常明显的: 文档流（Document flow）:浮动元素会脱离文档流，并使得周围元素环绕这个元素。而inline-block元素仍在文档流内。因此设置inline-block不需要清除浮动。当然，周围元素不会环绕这个元素，你也不可能通过清除inline-block就让一个元素跑到下面去。 水平位置（Horizontal position）：很明显你不能通过给父元素设置text-align:center让浮动元素居中。事实上定位类属性设置到父元素上，均不会影响父元素内浮动的元素。但是父元素内元素如果设置了display：inline-block，则对父元素设置一些定位属性会影响到子元素。（这还是因为浮动元素脱离文档流的关系）。 垂直对齐（Vertical alignment）：inline-block元素沿着默认的基线对齐。浮动元素紧贴顶部。你可以通过vertical属性设置这个默认基线，但对浮动元素这种方法就不行了。这也是我倾向于inline-block的主要原因。 空白（Whitespace）：inline-block包含html空白节点。如果你的html中一系列元素每个元素之间都换行了，当你对这些元素设置inline-block时，这些元素之间就会出现空白。而浮动元素会忽略空白节点，互相紧贴 IE6和IE7：Ie67对此属性部分支持。如果你要兼容这些浏览器，必须解决这个问题。这不是个大问题，但值得留意一下。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML5新特性","date":"2017-03-16T07:58:31.887Z","path":"2017/03/16/HTML5新特性/","text":"2017-02-12 22:41:11 星期二 1. 新的Doctype尽管使用&lt;!DOCTYPE html&gt;，即使浏览器不懂这句话也会按照标准模式去渲染 2. Figure元素用和来语义化地表示带标题的图片 &lt;figure&gt; &lt;img src=”path/to/image” alt=”About image” /&gt; &lt;figcaption&gt; &lt;p&gt;This is an image of something interesting. &lt;/p&gt; &lt;/figcaption&gt; &lt;/figure&gt; 3. 重新定义的已经被重新定义了，现在被用来表示小的排版，如网站底部的版权声明 4. 去掉link和script标签里面的type属性5. 加/不加 括号HTML5没有严格的要求属性必须加引号，闭合不闭合，但是建议加上引号和闭合标签 6. 让你的内容可编辑，只需要加一个contenteditable属性7. Email Inputs如果我们给Input的type设置为email，浏览器就会验证这个输入是否是email类型，当然不能只依赖前端的校验，后端也得有相应的校验 8. Placeholders这个input属性的意义就是不必通过javascript来做placeholder的效果了 9. Local Storage使用Local Storage可以永久存储大的数据片段在客户端（除非主动删除），目前大部分浏览器已经支持，在使用之前可以检测一下window.localStorage是否存在 10. 语义化的header和footer11. 更多的HTML5表单特性12. IE和HTML5默认的，HTML5新元素被以inline的方式渲染，不过可以通过下面这种方式让 其以block方式渲染 header, footer, article, section, nav, menu, hgroup {display: block;}不幸的是IE会忽略这些样式，可以像下面这样fix: document.createElement(”article”);document.createElement(”footer”);document.createElement(”header”);document.createElement(”hgroup”);document.createElement(”nav”);document.createElement(”menu”); 13. hgroup一般在header里面用来将一组标题组合在一起，如 &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt; Recall Fan Page &lt;/h1&gt; &lt;h2&gt; Only for people who want the memory of a lifetime. &lt;/h2&gt; &lt;/hgroup&gt; &lt;/header&gt; 14. Required属性required属性定义了一个input是否是必须的，你可以像下面这样声明 或者 15. Autofocus属性正如它的词义，就是聚焦到输入框里面 16. Audio支持HTML5提供了标签，你不需要再按照第三方插件来渲染音频，大多数现代浏览器提供了对于HTML5 Audio的支持，不过目前仍旧需要提供一些兼容处理，如 &lt;audio autoplay=”autoplay” controls=”controls”&gt; &lt;source src=”file.ogg” /&gt;&lt;!–FF–&gt; &lt;source src=”file.mp3″ /&gt;&lt;!–Webkit–&gt; &lt;a href=”file.mp3″&gt;Download this file.&lt;/a&gt; &lt;/audio&gt; 17. Video支持和Audio很像，标签提供了对于video的支持，由于HTML5文档并没有给video指定一个特定的编码，所以浏 览器去决定要支持哪些编码，导致了很多不一致。Safari和IE支持H.264编码的格式，Firefox和Opera支持Theora和Vorbis 编码的格式，当使用HTML5 video的时候，你必须都提供： &lt;video controls preload&gt; &lt;source src=”cohagenPhoneCall.ogv” type=”video/ogg; codecs=’vorbis, theora’” /&gt; &lt;source src=”cohagenPhoneCall.mp4″ type=”video/mp4; ’codecs=’avc1.42E01E, mp4a.40.2′” /&gt; &lt;p&gt; Your browser is old. &lt;a href=”cohagenPhoneCall.mp4″&gt;Download this video instead.&lt;/a&gt; &lt;/p&gt; &lt;/video&gt; 18. 预加载视频preload属性就像它的字面意思那么简单，你需要决定是否需要在页面加载的时候去预加载视频 19. 显示视频控制 20. 正则表达式由于pattern属性，我们可以在你的markup里面直接使用正则表达式了 &lt;form action=“” method=”post”&gt; &lt;label for=”username”&gt;Create a Username: &lt;/label&gt; &lt;input type=”text” name=”username” id=”username” placeholder=”4 &lt;&gt; 10 “pattern=”[A-Za-z]{4,10}” autofocus required&gt; &lt;button type=”submit”&gt;Go &lt;/button&gt; &lt;/form&gt; 21. 检测属性支持除了Modernizr之外我们还可以通过javascript简单地检测一些属性是否支持，如： if (!’pattern’ in document.createElement(’input’) ) {// do client/server side validation} 22. Mark元素把元素看做是高亮的作用，当我选择一段文字的时候，javascript对于HTML的markup效果应该是这样的： Search Results They were interrupted, just after Quato said, ”Open your Mind”. 23. 什么时候用HTML5已经引入了这么多元素，那么div我们还要用吗？div你可以在没有更好的元素的时候去用。 24. Data属性&lt;div id=”myDiv” data-custom-attr=”My Value”&gt; Bla Bla &lt;/div&gt; &lt;style&gt; h1:hover:after { content: attr(data-hover-response); color: black; position: absolute; left: 0; } &lt;/style&gt; &lt;h1 data-hover-response=”I Said Don’t Touch Me!”&gt; Don’t Touch Me &lt;/h1&gt; 27. Output元素元素用来显示计算结果，也有一个和label一样的for属性 28. 用Range Input来创建滑块HTML5引用的range类型可以创建滑块，它接受min, max, step和value属性可以使用css的:before和:after来显示min和max的值 &lt;input type=”range” name=”range” min=”0″ max=”10″ step=”1″ value=”&quot;&gt; input[type=range]:before { content: attr(min); padding-right: 5px; } input[type=range]:after { content: attr(max); padding-left: 5px;}","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"JS面向对象","date":"2017-03-16T07:57:11.770Z","path":"2017/03/16/JS面向对象/","text":"2030-01-26 23:33:13 星期六 基本概念ECMA关于对象的定义是：”无序属性的集合，其属性可以包含基本值、对象或者函数。“对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 类在现实生活中，相似的对象之间往往都有一些共同的组成特征。类，实际上是对象的设计蓝图或者制作配方。我们能基于相同的类创建出许多不同的对象，这些对象又会含有各自的属性和方法。 封装封装主要用于阐述对象中所包含（或封装的内容），它通常由两部分组成： 相关的数据（用于存储属性）基于这些数据所能做的事（所能调用的方法） 聚合聚合是指我们将现有对象合并成一个新对象的过程。例如：Book是由一个或多个author对象，publisher对象、若干chapter对象等组合而成的对象。 继承通过继承这种方式，我们可以非常优雅地实现对现有代码的重用。例如：我们定义了一个Person对象，他包含了wolk()，sleep(),speak(),eat()等方法，也包含了age,height,weight等属性，这时当我们再定义一个coder对象的时候，你不必将上述的属性和方法都重写一遍，你只需继承他即可，然后你只需将coder这个对象属于他自己的那部分特殊功能写出来。 多态上述实例中，我们的coder对象继承了person对象的一些属性和方法，这意味着这两个对象都实现了”speak”等方法，现在，我们的代码中有一个叫做James的变量，即便是我们不知道它是一个person对象还是一个coder对象的情况下，也依然可以直接调用该对象的”speak”方法。类似这种不同对象通过相同的方法调用实现各自行为的能力，我们就称之为“多态” 创建对象我们可以通过对象直接量、new关键字和object.create()函数来创建。 对象直接量创建对象最简单的方法就是在js中使用对象直接量，它是由若干名/值对组成的映射表，名/值对中间用冒号分隔，多个名/值对用逗号分隔。整个映射表用花括号（{}）括起来。 var empty = {};//没有任何属性的对象 var fruits = {apple:big , orange:yellow}; var company = { CEO : &quot;Tim Cook&quot;,//属性名字里有空格，必须用字符串表示 Designer:&quot;Ive&quot;; &quot;for&quot;:&quot;all audiences&quot;,//&quot;for&quot;是保留字，必须用引号 employees:{ firstname:&quot;David&quot;, //这里的属性名都没有引号 lastname:&quot;fill&quot; //这个属性的值是一个对象 } }; 对象里还可以嵌套对象（company里嵌套了employees对象） new关键字创建对象 关键字new后面跟随一个函数调用，这个函数称为构造函数（constructor），javascript语言核心的原始类型都包含内置的构造函数。 &lt;script type=&quot;text/javascript&quot;&gt; var obj = new Object();//创建一个空对象，和{}一样 var arr = new Array();//创建一个空数组，和[]一样 &lt;/script&gt; js原型-&gt;参照：javascript学习总结（五）原型和原型链详解 工厂模式由于ECMAScript中无法创建类，因此，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节： &lt;script type=&quot;text/javascript&quot;&gt; var Car = (function(){ var Car = function(model,year,miles){ this.model = model; this.year = year; this.miles = miles; }; return function(model,year,miles){ return new Car(model,year,miles); } })(); var Benz = new Car(&quot;Benz&quot;,2014,1000); var Audi = new Car(&quot;Audi&quot;,2013,800); &lt;/script&gt; 什么时候使用工厂模式? 以下几种情景下工厂模式特别有用： 对象的构建十分复杂需要依赖具体环境创建不同实例处理大量具有相同属性的小对象元素、属性和方法说到数组，我们常说其中包含的是元素，而当说到对象的时候，我们常会说其中包含的是属性。另外，对象的属性也可以是一个函数，因为函数本身也是一种数据，在这种情况下，我们会称该属性为方法： &lt;script type=&quot;text/javascript&quot;&gt; var wolf = { name :wolffy； run:function(){ alert(&quot;￼wolf,wolf!&quot;); } } &lt;/script&gt; 调用对象方法 var parrot = { name : “bage”, hair : “brown”, say : function(){ alert( ‘I am ‘ + parrot.name); } } parrot.say(); 注： 尽量使用点号表示法来访问对象的属性和方法。 不要在对象中使用带引号的属性标示。构造器函数另外，我们还可以使用构造器函数的方式来创建对象。看下面一个例子： function Person(name,age,occupation){ this.name = name; this.age = age; this.occupation = occupation; this.sayName = function(){ alert(this.name); } } var person1 = new Person(&quot;trigkit4&quot;,21,&quot;student&quot;); var person2 = new Person(&quot;Jack&quot;,25,&quot;Engineer&quot;); 优点 使用构造器函数的好处在于，它可以在创建对象时接收一些参数。按照惯例，构造函数的函数名应始终以一个大写字母开头，以区分普通函数。 区别 构造函数与普通函数的区别在于调用的方式不同，任何函数，只要通过new操作符来调用，那它就可以作为构造函数。 缺点 使用构造函数的主要问题是，每个方法都要在每个实例上重新创建一遍。 扩展阅读：javascript学习总结（五）原型和原型链详解 全局对象事实上，程序所在的宿主环境一般都会为其提供一个全局对象，而所谓的全局变量其实都只不过是该对象的属性罢了。 例如，当程序所在的宿主环境是web浏览器时，它所提供的全局对象就是window了。 内建对象内建对象大致分为三组： 数据封装类对象——包括Object、Array、Boolean、Number和String。这些对象代表着javascript中不同的数据类型，并且都拥有各自不同的typeof返回值，以及undefined和null状态工具类对象——包括Math、Date、RegExp等用于提供遍历的对象错误类对象——包括一般性错误对象及其它各种更特殊的错误类对象Object是js中所有对象的父级对象，这意味着我们创建的所有对象都继承于此。 所谓的空对象实际上并不是完全无用的，它还是包含了一些属性和方法的： 返回构造器函数的构造器属性返回对象描述字符串的toString()方法返回对象单值描述信息的valueOf()方法例如： var o = new Object();o.toString();//[object Object]ArrayArray()是一个用来构建数组的内建构造器函数。数组主要由如下三种创建方式： array = new Array()array = new Array([size])array = new Array(element0, element1, …, elementN)Array 对象方法方法 描述 concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。valueOf() 返回数组对象的原始值concat()方法：合并数组 [1,2]concat([3,4],[5,6]);//[1,2,3,4,5,6]join()方法： &lt;script type=&quot;text/javascript&quot;&gt; var a = [1,2,3]; a.join(&quot;&quot;);// =&gt;&quot;123&quot; &lt;/script&gt; //pop()方法：移除数组最后一个元素，并将其返回 &lt;script type=&quot;text/javascript&quot;&gt; var fruits = [&apos;apple&apos;,&apos;banana&apos;,&apos;pineapple&apos;]; fruits.pop();// pineapple console.log(fruits);//[&quot;apple&quot;,&quot;banana&quot;] &lt;/script&gt; //shift()方法：删除并返回数组的第一个元素。 &lt;script type=&quot;text/javascript&quot;&gt; var a = [1,2,3]; a.shift();//1 console.log(a);//[2,3] &lt;/script&gt; //slice(start,end)方法：截取数组的某一部分，不会对原数组进行任何修改 &lt;script type=&quot;text/javascript&quot;&gt; var num = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]; console.log(num.slice(1,4));//[&quot;b&quot;,&quot;c&quot;,&quot;d&quot;] console.log(num);//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;] &lt;/script&gt; //splice(start,delete_count,i1,i2…)方法：删除数组元素的同时添加新的元素。i1,i2为要插入的新元素 &lt;script type=&quot;text/javascript&quot;&gt; var arr = [&apos;js&apos;,&apos;css&apos;,&apos;html&apos;,&apos;php&apos;,&apos;c&apos;]; arr.splice(1, 2,&apos;python&apos;,&apos;jquery&apos;);//[&quot;css&quot;,&quot;html&quot;]","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jquery（三）","date":"2017-03-16T07:56:29.937Z","path":"2017/03/16/jquery（三）/","text":"8、类数组的操作jQuery选择器返回的是一个jQuery对象(该对象可能包括了多个dom节点),如果要对这些dom节点分别做不同的处理，就需要去遍历，需要调用jQuery对象提供的一些方法或者属性，称之为类数组的操作。类数组就是DOM节点数组 1)each(fn(i)):循环遍历每一个元素,this代表被迭代的dom对象，$(this)代表被迭代的jQuery对象。（i根据实际情况选择要还是不要）。 2)eq(index)：返回index+1位置处的jQuery对象 3)index(obj)：返回下标，其中obj可以是dom对象或者jQuery对象。 4)length属性：dom对象的个数 5)get()：返回dom对象组成的数组 6)get(index)：返回index+1个dom对象。 $(&apos;#b4&apos;).click(function(){ $(&apos;#s2 option&apos;).each(function(){ $(&apos;#s1&apos;).append($(this)); }); }); $(function(){ $(&apos;#b1&apos;).click(function(){ var $obj = $(&apos;ul li&apos;); $obj.each(function(i){ //i:表示正在被访问的那个节点的下标, //下标从0开始 if(i == 0){ $(this).css(&apos;font-size&apos;,&apos;50px&apos;); }else if(i==1){ $(this).css(&apos;font-style&apos;,&apos;italic&apos;); }else{ $(this).css(&apos;color&apos;,&apos;red&apos;).css(&apos;font-size&apos;,&apos;80px&apos;); } }); }); 9、jQuery对ajax编程的支持(1)load方法: 作用：是将服务器返回的数据直接添加到符合要求的节点之上，相当于obj.innerHTML = 返回的数据。 语法:$obj.load(请求地址,[请求参数]); 其中，请求参数可以有两种形式: 第一种：请求字符串，比如 “username=zs”,或者“username=zs&amp;age=22”。 第二种：javascript对象，比如 {‘username’:’zs’}，或者{‘username’:’zs’,’age’:22} load方法如果没有请求参数，会发送get请求，如果有请求参数，会发送post请求。 (2)$.get方法 作用：向服务器发送get请求 语法:$.get(url,[data],[callback],[type]): url:请求地址 data:请求参数,可以是请求字符串或者是js对象。格式为：{key,value} eg:{“name”:$(“#cost_name”).val()} callback: 是一个回调函数，用于处理服务器返回的数据，其格式 function(data,statusText), data是服务器返回的数据，如果服务器返回的是json字符串，$.get方法会自动将其转换成一个js对象或者js对象组成的数组。statusText是服务器处理的状态。 type:服务器返回的数据类型: text : 文本字符串 html : html内容 xml: 返回dom兼容的xml对象 json: json字符串 script: javascript脚本 function quoto(){ $(&apos;#tb1&apos;).empty(); $.get(&apos;quoto.do?&apos; + Math.random(),function(data){ //data:服务器返回的数据, 如果服务器 //返回的是json字符串，$.get方法会自动 //将其转换成一个js对象或者js对象组成的数组。 for(i=0;i&lt;data.length;i++){ $(&apos;#tb1&apos;).append( &apos;&lt;tr&gt;&lt;td&gt;&apos; + data[i].code +&apos;&lt;/td&gt;&lt;td&gt; &apos;+ data[i].name + &apos;&lt;/td&gt;&lt;td&gt; &apos; + data[i].price + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;); } },&apos;json&apos;); } $.post()格式同上。 $.put(url,[data],[callback],[type]): //焦点离开资费名输入框进行ajax检测 $(function(){ $(&quot;#name&quot;).blur(function(){ var name = $(this).val(); //发送ajax请求 $.post( &quot;validFeeName.action&quot;,//请求url {&quot;name&quot;:name},//提交参数 function(data){//data是服务器返回的ok值 if(data){//如果返回true $(&quot;#name_error&quot;).removeClass(&quot;error_msg&quot;) .html(&quot;资费名称可用&quot;); }else{//如果返回false $(&quot;#name_error&quot;).addClass(&quot;error_msg&quot;) .html(&quot;资费名称重复&quot;); } } ,&quot;text&quot;); }); }); (3)$.ajax方法 作用：可以设置不同的参数，控制ajax对象向服务器发请求。 语法:$.ajax(options): 其中，options是一个形如 key1:value1,key2,value2…}的js对象，用于指定发送请求的选项。 选项参数如下： url(string):请求地址 type(string):GET/POST data(object/string):请求参数，可以是请求字符串或者js对象 dataType(string) :服务器返回的数据类型 success(function):请求成功后调用的回调函数，有两个参数： function(data,textStatus),其中， data是服务器返回的数据， textStatus 描述状态的字符串。 error(function):请求失败时调用的函数，有三个参数 function(xhr,textStatus,errorThrown), xhr: ajax对象，即XMLHttpRequest对象。 textStatus和errorThrown，jQuery保证其中的一个参数可以获得异常的描述。 async: true(缺省)/false $(function(){ $(&apos;#s1&apos;).change(function(){ //先清空表格 $(&apos;#tb1&apos;).empty(); $.ajax({ &apos;url&apos;:&apos;carInfo.do&apos;, &apos;type&apos;:&apos;post&apos;, &apos;data&apos;:&apos;carName=&apos; + $(&apos;#s1&apos;).val(), &apos;dataType&apos;:&apos;xml&apos;, &apos;success&apos;:function(data){ //data:服务器返回的数据如果服务器返回的是xml, 浏览器不一样，则生成的dom树的结果也不一样，为了方便解析dom树，一般 我们使用$()函数将其转换成jQuery对象,然后进行遍历或者查找。 $(&apos;#tb1&apos;).append( &apos;&lt;tr&gt;&lt;td&gt;价格:&apos; + $(data).find(&apos;price&apos;).text() + &apos; 车重:&apos; + $(data).find(&apos;weight&apos;).text() + &apos;&lt;/td&gt;&lt;td&gt;门数:&apos; + $(data).find(&apos;doors&apos;).text() + &apos; 长宽高:&apos; + $(data).find(&apos;size&apos;).text() + &apos;&lt;/td&gt;&lt;td&gt;排量:&apos; + $(data).find(&apos;vol&apos;).text() + &apos; 加速性能:&apos; + $(data).find(&apos;speed&apos;).text() + &apos;&lt;/td&gt;&lt;/tr&gt;&apos;); $(&apos;#d2&apos;).show(); setTimeout(function(){ $(&apos;#d2&apos;).fadeOut(&apos;slow&apos;); },3000); }, &apos;error&apos;:function(){ alert(&apos;服务暂时不可用&apos;); } }); }); }); 10、给JQuery添加插件可以把JQuery看做一个类，给JQuery添加插件就是给Jquery类中添加方法。相当于在Java中给String类增加方法（当然是不可以增加的），这样就可以用JQuery对象直接调用了，方便多次使用。 使用场合：使用频率高的方法， JQuery经典总结 eg:下面代码的作用是对指定的文本框(errorContent)进行非空验证，并输出（errorMsg）验证提示信息。 写法一： $.fn.required = function(errorContent, errorMsg) { var val = $(this).val(); if (val != null &amp;&amp; val.length &gt; 0) { $(errorContent).text(&quot;&quot;); return true; } else { $(errorContent).text(errorMsg); return false; } } 写法二： ;(function($){ $.fn.extend({ rangeLength:function(errorContent, errorMsg){ var val = $(this).val(); if (val != null &amp;&amp; val.length &gt; 0) { $(errorContent).text(&quot;&quot;); return true; } else { $(errorContent).text(errorMsg); return false; } } }); })(jQuery) &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&quot;#submit&quot;).bind(&quot;click&quot;,function(){ var b1 = $(&quot;#adminCode&quot;) .required($(&quot;#error_adminCode&quot;),&quot;账号必须填写&quot;); var b2 = $(&quot;#password&quot;) .required($(&quot;#error_password&quot;),&quot;密码必须填写&quot;) if(b1 &amp;&amp; b3) { $(&quot;#loginForm&quot;).submit(); } }); }); &lt;/script&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jquery（二）","date":"2017-03-16T07:55:49.158Z","path":"2017/03/16/jquery（二）/","text":"2030-01-24 22:03:57 星期四 6、事件处理机制 event1)、事件绑订 bind(type,fn) $(function(){ $(&apos;#d1&apos;).bind(&apos;click&apos;,function(){ $(this).html(&apos;hello java&apos;); }); }); 2)、绑订方式的简写形式 $(function(){ $(&apos;#d1&apos;).click(function(){ $(this).html(&apos;hello java&apos;); }); }); 3)、合成事件 hover(mouseenter,leave) : 模拟光标悬停事件，区别于CSS中的伪类 $(&apos;.s1&apos;).hover(function(){ $(this).addClass(&apos;s2&apos;); },function(){ $(this).removeClass(&apos;s2&apos;); }); 相当于以下连个函数的合成： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }); $(&apos;.s1&apos;).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); 上面的mouseenter和mouseleave两个函数可以合并为： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); toggle(fn1,fn2…)：模拟鼠标连续单击事件 $(&apos;#a1&apos;).toggle(function(){ $(&apos;#d1&apos;).show(&apos;slow&apos;); },function(){ $(&apos;#d1&apos;).hide(&apos;slow&apos;); }); 4)、事件冒泡 (1)获得事件对象 依据事件对象获得事件源(即哪一个节点产生了该事件，返回的是原始的DOM节点)，其中e不再是DOM对象，而是封装之后的JQuery对象。 var srcObj = e.srcElement; //ie var srcObj = e.target; //firefox,chrome var srcObj = e.srcElement || e.target; //同时兼容ie,firefox,chrome alert(srcObj.innerHTML); 依据事件对象获得鼠标点击的坐标（相对于屏幕） alert(e.clientX + ‘:’ + e.clientY); (2)事件对象的属性 event.type event.target:返回事件源(是dom对象) event.pageX/pageY 获得相对于当前浏览器页面的坐标 (3)停止冒泡 event.stopPropagation() function clickA(e){ alert(&quot;你点击了一个链接&quot;); //取消冒泡 e.stopPropagation(); } function clickDiv(e){ alert(&quot;你点击了一个Div&quot;); } 上列中，链接处于div中，当取消冒泡后，单击链接便不会触发div上面 onlick事件的执行，上例中的输出结果为：你点击了一个链接 (4)停止默认行为 event.preventDefault() $(function(){ $(&apos;#d1&apos;).click(function(e){ var flag = confirm(&apos;确定删除吗&apos;); if(!flag){ e.preventDefault(); } }); }); 设置停止了默认行为后，表单提交按钮便不会自动提交了。相当于： &lt;input type=”submit” id=”d1” name=”username” onclick=”return fonfirm(‘确定要删除吗’)”/&gt; 5)、模拟操作 trigger(&apos;click&apos;) $(function(){ $(&apos;#b1&apos;).click(function(){ //$(&apos;#username&apos;).trigger(&apos;focus&apos;); $(&apos;#username&apos;).focus(); }); }); 上列模拟了文本框控件获得焦点的行为，当点击按钮后，文本框便获得了焦点，表现为文本框内有光标闪动。 mouseenter和mouseover效果一样，可以互换使用 mouseout和mouseleave效果一样，可以互换使用 7、动画 animate 1)show(), hide() 作用：通过同时改变元素的宽度与高度来实现显示和隐藏的效果。 语法:show(速度,callback); 速度: ‘slow’,’normal’,’fast’ / 800(毫秒) callback: 在动画执行完毕之后，会执行这个函数 $(function(){ $(&apos;#btn1&apos;).click(function(){ $(&apos;#sp1&apos;).hide/show(500); $(&apos;#sp1&apos;).hide/show(500,function(){alert(&quot;H&quot;);}); }); }); 2)、fadeIn() fadeOut() 作用， 通过改变元素的不透明度来实现显示和隐藏的效果。 语法: fadeIn/fadeOut(速度,callback); $(function(){ $(&apos;#btn1&apos;).click(function(){ $(&apos;#sp1&apos;).fadeIn/fadeOut(500); $(&apos;#sp1&apos;).fadeIn/fadeOut(500,function(){alert(&quot;H&quot;);}); }); }); 3)、slideUp() slideDown() 作用：通过改变元素的高度来实现显示和隐藏的效果。 语法: slideUp(速度,callback); $(function(){ $(&apos;#a1&apos;).toggle(function(){ $(&apos;#d1&apos;).slideDown(&apos;slow&apos;); },function(){ $(&apos;#d1&apos;).slideUp(&apos;slow&apos;); }); }); 4)、自定义动画 animate(params,speed,callback) 语法: JQuery经典总结 params:是一个js对象，描述了动画执行结束时元素的样式，比如: {‘top’:’600px’,’left’:’200px’} speed: 毫秒 callback: 在动画执行完毕之后，会执行这个函数 $(this).animate({&apos;left&apos;:&apos;500px&apos;},4000); $(this).animate({&apos;top&apos;:&apos;250px&apos;},2000).fadeOut(&apos;slow&apos;);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jquery（一）","date":"2017-03-16T07:54:57.706Z","path":"2017/03/16/jquery（一）/","text":"2030-01-22 22:20:00 星期二 jQuery基础1)dom对象 — &gt; jQuery对象 var $obj = $(dom对象); var $d = $(div); 2)jQuery对象 —- &gt; dom对象 第一种方式: var obj = $obj.get(0); 第二种方式: var obj = $obj.get()[0]; (3) jQuery与prototype如何同时使用？ 因为jQuery与prototype都使用$函数，需要使用 var $a = jQuery.noConflict()将$函数改名为”$a”。 jQuery选择器1)、基本选择器 selector/a1.html ——&gt; 匹配所有元素 #id ——&gt; 根据给定的ID匹配一个元素。.class ——&gt; 根据给定的类匹配元素。 element ——&gt;根据给定的元素名匹配所有元素selector1,selector2..selectorn ——&gt;将每一个选择器匹配到的元素合并 2)、层次选择器select1 select2——&gt;匹配select1下的所有儿子元素（不包含孙子元素） select1&gt;select2——&gt;匹配select1下的所有子元素（包含孙子元素） select1+select2——&gt;匹配紧跟在select1后的第一个兄弟元素（同辈元素） select1~select2——&gt;匹配select1后的所有兄弟元素（及找到所有的同 3)、过滤选择器a.基本过滤选择器 selector/ a3.html:first——&gt;获取第一个元素 :last——&gt;获取第一个元素 :not(selector)——&gt;获取去除给定元素后的所有匹配元素 :even——&gt;匹配所有索引值为偶数的元素，从 0 开始计数 :odd——&gt;匹配所有索引值为奇数的元素，从 0 开始计数 :eq(index)——&gt;匹配一个给定索引值的元素 :gt(index)——&gt;匹配所有大于给定索引值的元素 :lt(index)——&gt;匹配所有小于给定索引值的元素 b.内容过滤选择器 selector/ a4.html:contains(text)——&gt;匹配包含给定文本的元素 :empty ——&gt;匹配没有子元素且文本为空的元素:has(selector)——&gt;匹配含有选择器所匹配的元素的元素 :parent ——&gt; 跟empty相反,即有子节点，或者内容不为空的节点。 c.可见性过滤选择器 selector/ a5.html:hidden——&gt;匹配所有不可见元素，或者type为hidden的元素 :visible——&gt;匹配所有的可见元素 d.属性过滤选择器 selector/ a6.html[attribute]——&gt;匹配包含给定属性的元素 [attribute=value]——&gt;匹配给定的属性是某个特定值的元素 [attribute!=value]——&gt;匹配属性不等于特定值的元素。 e.子元素过滤选择器 selector/ a7.html:nth-child(index/even/odd)——&gt;匹配其父元素下的第N个子或奇 偶元素（即同辈中第N个元素） :first-child——&gt;匹配其父元素下第一个子元素 :last-child——&gt;匹配其父元素下最后一个子元素 f.表单对象属性过滤选择器 :enabled——&gt;匹配所有可用元素 :disabled——&gt;匹配所有不可用元素 :checked——&gt;匹配复选框、单选按钮中被选中的元素 :selected——&gt;匹配所有选中的option元素 4)、表单选择器:input——&gt;匹配所有 input, textarea, select 和 button 元素 :text——&gt;匹配所有的单行文本框 :pasword——&gt;匹配所有密码框 :radio——&gt;匹配所有单选按钮 :checkbox——&gt;匹配所有复选框 :submit——&gt;匹配所有提交按钮 :image——&gt;匹配所有图像域 :reset——&gt;匹配所有重置按钮 :button——&gt;匹配所有按钮 :file——&gt;匹配所有文件域 :hidden——&gt; 匹配所有不可见元素，或者type为hidden的元素 dom操作1)、查询 dom / d1.html利用选择器找到要操作的节点之后，访问节点的html内容、text内容、节点的值以及节点的属性值。除此之外，还可以修改这些值。 a, html() : 相当于innerHTML b, text(): 获取div,p,span等元素内文本相当于innerText， c, val():获取文本框text、下拉列表select或选择框checkbox的值 d, attr():获取或设置节点的属性值 2)、创建 dom / d2.html$(html); 3)、插入节点append():向每个匹配的元素内部追加内容，当做最后一个儿子 prepend():向每个匹配的元素内部前置内容。当做第一个儿子 after():在每个匹配的元素之后插入内容，当做后一个兄弟 before():在每个匹配的元素之前插入内容，当做前一个兄弟 var $obj = $(&apos;&lt;div&gt;首先是培养兴趣，然后是多写代码&lt;/div&gt;&apos;); $(&apos;body&apos;).append($obj); 也可以简化为 $(&apos;body&apos;).append(&apos;&lt;div&gt;首先是培养兴趣，然后是多写代码&lt;/div&gt;&apos;); 4)、删除节点 dom / d3.htmlremove()：$(‘ul li:eq(1)’).remove(); remove(selector)：$(‘ul li’).remove(‘#l1’); empty():清空节点：$(‘ul li:eq(1)’).empty(); 5)、复制节点 dom / d6.htmlclone():不复制行为 clone(true):使复制的节点也具有行为 6)、属性操作 dom / d7.html读取：attr(‘ ‘); $(“img”).attr(“src”); 设置： attr(‘ ‘,’ ‘) $(“img”).attr(‘src’, ‘test.jpg’); s(&apos;#d1&apos;).attr(&apos;value&apos;,&apos;font-size:40px;color:red;&apos;); $(&apos;#form1 input:disabled&apos;).attr(&apos;disabled&apos;,false); 或者一次设置多个 attr({“”:””,””:””}); eg:$(&apos;div&apos;).attr({&apos;class&apos;:&apos;s1&apos;,&apos;style&apos;:&apos;color:red;&apos;}); 删除：removeAttr(‘ ‘) 7)、样式操作 dom / d8.html 获取和设置: attr(“class”,””), attr(“style”,””); alert($(&apos;div&apos;).attr(&apos;class&apos;)); $(&apos;div&apos;).attr(&apos;class&apos;,&apos;s1&apos;) $(&apos;div&apos;).attr(&apos;style&apos;,&apos;color:blue;&apos;); 追加:addClass(‘’):$(‘div’).addClass(‘s2 s3’); 移除:removeClass(‘’) :$(‘div’).removeClass(‘s3’); 或者removeClass(‘s1 s2’) 或者removeClass()//会删除所有样式 切换样式：toggleClass:$(‘div’).toggleClass(‘s3’); 是否有某个样式 hasClass(‘’):alert($(‘div’).hasClass(‘s3’)); 读取css(‘’) 设置css(‘’,’’)或者css({‘’:’’,’’:’’})//设置多个样式 $(&apos;table tr:first&apos;).css(&apos;background-color&apos;,&apos;#cccccc&apos;); $(&apos;table tr:first&apos;).css({&apos;background-color&apos;:&apos;#cccccc&apos;,’width’:’3px’}); 8)、遍历节点 dom / d9.htmlchildren()/children(selector):var $obj = $(‘#d0’).children(‘div’); 只考虑子元素，不考虑其它后代元素。 next(selector): 下一个兄弟$(‘#d2’).next() prev(selector):上一个兄弟$(‘#d2’).prev() siblings(selector):其它兄弟， $(&apos;#d2&apos;).siblings(‘#id’)除#d2之外的其他兄弟节点 也可以写成：$(‘#id’).siblings() parent():父节点,不是爷爷节点 find(selector): 从当前节点开始，查找所有后代，包括孙子。 事件处理机制 event1)、事件绑订 event/e1.html$(function(){ $(&apos;#d1&apos;).bind(&apos;click&apos;,function(){ $(this).html(&apos;hello java&apos;); }); }); 2)、绑订方式的简写形式上个列子可以简写为： $(function(){ $(&apos;#d1&apos;).click(function(){ $(this).html(&apos;hello java&apos;); }); }); 3)、合成事件 event/e2.html e3.htmlhover(mouseenter,leave) : 模拟光标悬停事件，区别于CSS中的伪类 $(&apos;.s1&apos;).hover(function(){ $(this).addClass(&apos;s2&apos;); },function(){ $(this).removeClass(&apos;s2&apos;); }); 相当于以下连个函数的合成： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }); $(&apos;.s1&apos;).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); 上面的mouseenter和mouseleave两个函数可以合并为： $(&apos;.s1&apos;).mouseenter(function(){ $(this).addClass(&apos;s2&apos;); }).mouseleave(function(){ $(this).removeClass(&apos;s2&apos;); }); toggle(fn1,fn2...)：模拟鼠标连续单击事件 $(&apos;#a1&apos;).toggle(function(){ $(&apos;#d1&apos;).show(&apos;slow&apos;); },function(){ $(&apos;#d1&apos;).hide(&apos;slow&apos;); }); 4)、事件冒泡(1)获得事件对象 event/e4.html e5.html e6.html click(function(e){ }); function f1(e){ 依据事件对象获得事件源(即哪一个节点产生了该事件，返回的是原始的DOM节点)，其中e不再是DOM对象，而是封装之后的JQuery对象。 var srcObj = e.srcElement; //ie var srcObj = e.target; //firefox,chrome var srcObj = e.srcElement || e.target; //同时兼容ie,firefox,chrome alert(srcObj.innerHTML); 依据事件对象获得鼠标点击的坐标（相对于屏幕） alert(e.clientX + &apos;:&apos; + e.clientY); (2)事件对象的属性 event/e6.htmlevent.type event.target:返回事件源(是dom对象) event.pageX/pageY 获得相对于当前浏览器页面的坐标 (3)停止冒泡 event / e7.htmlevent.stopPropagation() function clickA(e){ alert(&quot;你点击了一个链接&quot;); //取消冒泡 e.stopPropagation(); } function clickDiv(e){ alert(&quot;你点击了一个Div&quot;); } 上列中，链接处于div中，当取消冒泡后，单击链接便不会触发div上面 onlick事件的执行，上例中的输出结果为：你点击了一个链接 (4)停止默认行为 event / e8.htmlevent.preventDefault() $(function(){ $(&apos;#d1&apos;).click(function(e){ var flag = confirm(&apos;确定删除吗&apos;); if(!flag){ e.preventDefault(); } }); }); 设置停止了默认行为后，表单提交按钮便不会自动提交了。相当于： &lt;input type=”submit” id=”d1” name=”username” onclick=”return fonfirm(‘确定要删除吗’)”/&gt; 5)、模拟操作 event / e9.htmltrigger(&apos;click&apos;) $(function(){ $(&apos;#b1&apos;).click(function(){ //$(&apos;#username&apos;).trigger(&apos;focus&apos;); $(&apos;#username&apos;).focus(); }); }); 上列模拟了文本框控件获得焦点的行为，当点击按钮后，文本框便获得了焦点，表现为文本框内有光标闪动。 mouseenter和mouseover效果一样，可以互换使用 mouseout和mouseleave效果一样，可以互换使用","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"AJAX","date":"2017-03-16T07:54:22.632Z","path":"2017/03/16/AJAX/","text":"1/22/2017 9:40:51 PM 原生JavaScript的AJAX首先，获取XHR对象，它被内嵌在浏览器中了，主要为了区别IE6这类特殊浏览器，不然直接调用XMLHttpRequest这个方法即可获取。成功获取对象之后使用open（）方法传入请求方法，请求url。这个onreadystatechange是一个回调函数，负责接收服务器响应数据的处理，这里类似将它重写，浏览器会调用这个方法处理返回数据。send方法在GET请求中只需要传入null，因为send方法是把数据放在请求体内，只有POST方式才会往send里写数据。回调函数的写法是按照视频代码抄写的。在responseText可以获得服务端写来的数据。 var XHR=false; function createXHR(){ if(window.XMLHttpRequest){ XHR=new XMLHttpRequest(); }else{ XHR=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } } function checkUsername(){ var username=document.getElementById(&quot;check&quot;).value; createXHR(); XHR.open(&quot;get&quot;,&quot;checkUsername?username=&quot;+username,true); XHR.onreadystatechange=showMsgCallback; XHR.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); XHR.send(); } function showMsgCallback(){ if(XHR.readyState==4){ if(XHR.status==200){ var text=XHR.responseText.toString(); alert(text==&apos;no&apos;); console.log(text); if(text==&quot;yes&quot;){ alert(1); document.getElementById(&quot;msg&quot;).innerHTML=&quot;此用户名已注册!&quot;; } else if(text==&quot;no&quot;) { alert(2); document.getElementById(&quot;msg&quot;).innerHTML=&quot;此用户可以注册&quot;; } } } } 三种Jquery的ajax写法&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;ajax交互&lt;/title&gt; &lt;script src=&quot;jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() { $(&apos;#button1&apos;).click(function() { var text = $(&apos;#msg1&apos;); $.ajax({ type : &quot;POST&quot;, url : &quot;jquery&quot;, data : &quot;username=ssss&quot;, dataType : &apos;text&apos;, success : function(result) { if (result==&quot;success&quot;) { text.text(&quot;&quot;); text.append(&quot;成功&quot;); }else{ text.text(&quot;&quot;); text.append(&quot;失败&quot;); } }, error : function() { text.text(&quot;&quot;); text.append(&quot;操作出错&quot;); } }); }); }); $(document).ready(function(){ $(&apos;#button2&apos;).click(function(){ var text = $(&apos;#msg2&apos;); $.post(&apos;jquery&apos;, &apos;username=xxxx&apos;,function(result){ if (result===&quot;success&quot;) { text.text(&quot;成功&quot;); }else{ text.text(&quot;失败&quot;); } },&apos;text&apos;); }); }); $(document).ready(function(){ $(&apos;#button3&apos;).click(function(){ var text = $(&apos;#msg3&apos;); $.get(&apos;jquery&apos;,&apos;username=zzzzz&apos;,function(result){ if (result===&quot;success&quot;) { text.text(&quot;成功&quot;); }else{ text.text(&quot;失败&quot;); } }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;button1&quot;&gt;点击使用$ajax发送&lt;/button&gt; &lt;span id=&quot;msg1&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;button id=&quot;button2&quot;&gt;点击使用$post发送&lt;/button&gt; &lt;span id=&quot;msg2&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;button id=&quot;button3&quot;&gt;点击使用$get发送&lt;/button&gt; &lt;span id=&quot;msg3&quot;&gt;&lt;/span&gt; &lt;br/&gt; &lt;/body&gt; &lt;/html&gt; 应用&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; &lt;%@ taglib prefix=&quot;sx&quot; uri=&quot;/struts-dojo-tags&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;AJAX范例&lt;/title&gt; &lt;sx:head/&gt; &lt;script src=&quot;jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function(){ $(&apos;#usrname&apos;).blur(function(){ $.ajax({ type : &quot;POST&quot;, url : &quot;checkUsername&quot;, data : &apos;name=&apos;+$(&apos;#usrname&apos;).val(), dataType : &apos;text&apos;, success:function(data){ if(data===&apos;yes&apos;) $(&apos;#msg&apos;).text(&apos;可以登录&apos;); else if(data===&apos;no&apos;) $(&apos;#msg&apos;).text(&apos;无法登录&apos;); } }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;form action=&quot;&quot;&gt; &lt;span id=&quot;msg&quot;&gt;&lt;/span&gt;&lt;br/&gt; 用户名:&lt;input id=&quot;usrname&quot; name=&quot;name&quot; type=&quot;text&quot;/&gt; &lt;br/&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot;/&gt; &lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/form&gt; &lt;/center&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"新建,模板,小书匠","slug":"新建-模板-小书匠","permalink":"http://yoursite.com/tags/新建-模板-小书匠/"}]},{"title":"DOM","date":"2017-03-16T07:53:42.784Z","path":"2017/03/16/DOM/","text":"2017-01-21 22:29:04 星期一 DOM即文件对象模型（Document Object Model，简称DOM）HTML DOM 定义了访问和操作 HTML 文档的标准方法。简言之： （1）其实它就是将 HTML 文档以节点（Node）为单位将其表达为等级明确、节构整齐的树节构，以便于简捷地操作文档的元素。 （2）它在一定程度上对HTML（或XML）元素（节点）实现了“黑盒”访问和操作。例如，我们获得了一个节点对象，然后直接用它的parentNode属性获得它的父节点（如果父节点存在的话），进而访问或操作父节点对象，而我们无需知道它的父节点是什么类型的对象，它的id是什么等等，父节点就是封装好的一个“黑盒”，我们不知道它的id、name等所有属性，依然可以利用dom技术随意操作它。 DOM对节点（Node）的定义：Ø 整个文档是一个文档节点Ø 每个 HTML 标签是一个元素节点Ø 包含在 HTML 元素中的文本是文本节点Ø 每一个 HTML 属性是一个属性节点Ø 注释属于注释节点 DOM中节点的层级关系层级关系很明确也很简单，根据节点之间的关系将其分为三种：父（parent）、子（child）、同胞（sibling） DOM对象树DOM将每一个HTML或XML的文档都看待成内存中的一个对象树浏览器中的一个页面对应一个HTML文档，因此有一颗与之对应的HTML的DOM树。浏览器中一个页面可能处理很多个XML的文档，因此可能有很多颗XML的DOM树。 DOM对象树种的常用节点 接口 nodeType常量（IE不支持） nodeType值 备注 Element Node.ELEMENT_NODE 1 元素节点（标签） Atrr Node.ATTRIBUTE_NODE 2 属性节点（属性） Text Node.TEXT_NODE 3 文本节点（文本） Comment Node.COMMENT_NODE 8 注释节点（注释） Document Node.DOCUMENT_NODE 9 文本根节点 DOM对象树不同节点的名值对比 节点 nodeName（节点名） nodeValue(节点值) Element元素节点 对应标签名的大写形式如：HTML Null Attr属性节点 文档中定义的属性名如：type 文档中定义的属性值如：button Text文本节点 #text 文本内容如：133 Comment注释节点 #comment 注释内容如：comment Document根节点 #document Null 根节点的属性和方法：&lt;script type=&quot;text/javascript&quot; &gt; function testapi(){ //获得根节点元素 var htmlrootElement=document.documentElement; //获得指定的元素节点 var divNode=document.getElementById(&quot;div1&quot;); //获得整个页面所有的div元素节点 var divNodes=document.getElementsByTagName(&quot;div&quot;); //创建元素节点 var newdivNode=document.createElement(&quot;div&quot;); //创建文本节点 var newTextNode=document.createTextNode(&quot;aaaa&quot;); } &lt;/script&gt; 元素节点的属性和方法//根据标签名获得元素节点 var divNode2=document.getElementById(&quot;div2&quot;); var divNodes2=divNode2.getElementsByTagName(&quot;div&quot;); //操作属性 var inputtext=document.getElementById(&quot;inputtext&quot;); var flag=inputtext.hasAttribute(&quot;value&quot;); inputtext.setAttribute(&quot;value&quot;, &quot;aaacede&quot;); var textValue=inputtext.getAttribute(&quot;value&quot;); flag=inputtext.hasAttribute(&quot;value&quot;); inputtext.removeAttribute(&quot;value&quot;); alert(&quot;完成&quot;); 所有节点（Node）都拥有的属性和方法 //返回元素节点包含的属性节点 var attributes=inputtext.attributes; //nodeName nodeValue nodeType var inputName=inputtext.nodeName; var nodetype=inputtext.nodeType; var nodevalue=inputtext.nodeValue; //获取所有的子节点 var childs=divNode2.childNodes; //获取父节点 var parent=divNode2.parentNode; //获取第一个子节点和最后一个子节点 var first=divNode2.firstChild; var last=divNode2.lastChild; //获取兄弟节点 var next=divNode2.nextSibling; var last=divNode2.previousSibling; //判断是否有子节点 var flag2=divNode2.hasChildNodes(); //追加节点 newdivNode.appendChild(newTextNode); divNode2.appendChild(newdivNode); var new2=document.createElement(&quot;div&quot;); var text2=document.createTextNode(&quot;insert&quot;); new2.appendChild(text2); divNode2.insertBefore(new2,divNode2.firstChild); var new3=document.createElement(&quot;div&quot;); var text3=document.createTextNode(&quot;insert3&quot;); new3.appendChild(text3); divNode2.insertBefore(new3, null); divNode2.insertBefore(new3,divNode2.firstChild); //移除节点 var remove=divNode2.removeChild(new3); var new4=document.createElement(&quot;div&quot;); var text4=document.createTextNode(&quot;insert4&quot;); new4.appendChild(text4); //如果第一个参数曾经是当前节点的子节点，那么这个参数对应的节点会被移动到第二个参数对应的节点的位置。 //第二个参数对应的节点被删除了。 var replace=divNode2.replaceChild(new4,divNode2.getElementsByTagName(&quot;div&quot;)[0]); //clone节点 var clone1=divNode2.cloneNode(true); var clone2=divNode2.cloneNode(false); AJAX,DOM 和javascript的关系DOM能够为javascript引擎公开网页。通过DOM，可以采用编程的方式操作文档的结构。Web页面的DOM表示是一个树状结构，由元素或点组成。节点可以包含很多子节点。javascript通过全局变量document公开当前Webde根节点，这个变量是所有DOM操作的起点。DOM使用容器的属性来做索引，而不是使用数字做索引。DOM中元素的关系可以看作是HTML清单的镜像。这种关系可以是双向的，修改DOM将改变HTML标记，随之会反映在页面的现实上。用一个简单一点的关系表示就是：DOM–数据–&gt;jQuery–利用–&gt;Ajax–请求–&gt;后台后台–回应Ajax请求–&gt;Jquery–操作dom变现请求–&gt;dom","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"flag","date":"2017-03-16T07:52:45.629Z","path":"2017/03/16/flag/","text":"2017-01-20 21:34:57 星期日今天没学习 该打 偶然看到入门前端学习路线 立个flag 静心 慢慢学吧~ 一、学习HTML5和CSS3基础随着这移动互联网快速发展的时代，尤其是4G时代，HTML5+CSS3已然成为新一代的web前端技术。 随着HTML5的发展和普及，了解 HTML5 也将成为 Web开发人员的必修课。涉及到网页外观时，就需要学习 CSS 了，它可以帮你把网页做得更美观。 利用 HTML5 和 CSS3 模拟一些你所见过的网站的排版和布局（色彩，图片，文字样式等等）。 如：京东首页的实现 当然，达内Web前端开发课程第一阶段还会学习 PS设计工具使用和互联网UI设计理论。在阶段项目实战中，大家常见的京东详情页、360专题页、淘宝首页都可以实现。 二、学习JavaScript，了解DOMJavaScript 是一种能让你的网页更加生动活泼的程序语言。学习 JavaScript 的基本语法，学会用 JavaScript 操作网页中 DOM 元素。 在达内 Web前端开发课程第二阶段完全可以实现大家平常喜欢玩的 2048 游戏。（是不是感觉挺有意思） 接着学习使用一些 JavaScript 库，比如 Jquery 是大部分 Web开发人员都喜欢用的，通过 Jquery 可以有效的提高 JavaScript 的开发效率。 三、学习Web前端核心学习 Jquery 之后，大家就要学习 HTML5 高级阶段（HTML5 Canvas 绘图、HTML5 SVG、音频和视频处理、表单处理、表单验证…等） 达内培训每学习一个阶段，都是让学员真正进行项目实战，在熟悉和消化所学习知识的同时，增加自己的项目经验和团队协作能力。 在学习 Jquery 和 HTML5 学习结束后，就可以完成飞机大战、飞扬的小鸟以及复杂订单的实现。 四、学习HTTP协议及Server端技术服务器端脚本编程（后台开发）也是Web开发人员的基本功之一，达内学员现在学习的是最流行的php。 要构建动态页面通常会使用到数据库，通常PHP使用Oracle、MySQL数据库。 对于Web服务器来说，Apache 一个就已经是了。那么Apache、php、数据库，该怎么理解它们的关系？ 1、Apache是服务器基础，php和数据库都需要Apache来协调工作 2、php是脚本解释，如果不用php，那么Apache出来的东西就只是静态的，而不能在服务器实现功能 3、数据库完全可以单独使用，但是和Apache、php一起，则是由php代码调用数据库接口，而apache就负责解释php代码，让他能真正地实现对数据库的调用 这个阶段的项目实战是实现京东订单页和个人论坛。 五、学习Web前端高级技术当你掌握了HTML5，CSS3，JavaScript等技术之后，就应该找一个Web框架加快你的Web开发速度，使用框架可以节约你很多时间。 在达内学习的Bootstrap是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷，是web前端开发者最喜欢，也是现在企业里最常用的前端框架。 Angular JS是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVC编程、模块化、控制器、路由、事件绑定等等。 AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发。如同其他的抽象技术一样，这也会损失一部分灵活性。换句话说，并不是所有的应用都适合用AngularJS来做。AngularJS主要考虑的是构建CRUD应用。幸运的是，至少90%的WEB应用都是CRUD应用。但是要了解什么适合用AngularJS构建，就得了解什么不适合用AngularJS构建。 从最简单的HTML5基础到Web前端高级技术，内容还是不少滴！要想精通这里的每一样技术，都得下苦功夫才行。四个月的时间，在达内讲师的指导下，足够你对Web前端开发产生一个有效的认识，并且找到理想的工作。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js鼠标事件改变样式","date":"2017-03-16T07:51:50.681Z","path":"2017/03/16/js鼠标事件改变样式/","text":"2017-01-19 21:37:48 星期六1. z-index当你定义的CSS中有position属性值为absolute、relative或fixed，用z-index此取值方可生效。此属性参数值越大，则被层叠在最上面。 2 .标签中的 href=”javascript:;”javascript:是表示在触发默认动作时，执行一段JavaScript代码，而 javascript:; 表示什么都不执行，这样点击时就没有任何反应。一般在这种情况下，会给绑定一个事件回调，来执行业务，如： document.getElementById(&apos;jsPswEdit&apos;).addEventListener(&apos;click&apos;, function(e) { e.preventDefault(); // 当&lt;a&gt;触发click时，处理业务 }, false); href=”javascript:;”就是去掉a标签的默认行为，跟href=”javascript:void(0)”是一样的，void 是JavaScript 的一个运算符，void(0)就是什么都不做的意思 3 .详解href=”#”与href=”javascript:void(0)”的区别“#”包含了一个位置信息默认的锚点是#top 也就是网页的上端而javascript:void(0) 仅仅表示一个死链接这就是为什么有的时候页面很长浏览链接明明是＃可是跳动到了页首而javascript:void(0) 则不是如此所以调用脚本的时候最好用void(0)或者 、等 4 .getComputedStyle、currentStyle的区别与用法getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读，而element.style能读能写。getComputedStyle方法IE6~8是不支持的。 currentStyle是IE浏览器的一个属性，其与element.style在使用形式上类似，element.currentStyle，差别在于element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的属性等）。因此，从作用上将，getComputedStyle方法与currentStyle属性走的很近，形式上则style与currentStyle走的近。不过，currentStyle属性貌似不支持伪类样式获取，这是与getComputedStyle方法的差异。 5 .CSS伪类CSS伪类是选择符的螺栓，用来指定一个或者与其相关的选择符的状态。它们的形式是selector:pseudoclass{property:value;}，简单地用一个半角英文冒号(:)来隔开选择符和伪类。 CSS很多的建议并没有得到浏览器的支持，但有四个可以安全使用的用在连接上的CSS伪类。 ◆link用在为访问的连接上。 ◆visited用在已经访问过的连接上。 ◆hover用于鼠标光标置于其上的连接。 ◆active用于获得焦点(比如，被点击)的连接上。 鼠标移入移除改变样式实现代码 * Created by YYD on 2017/1/19. */ function getStyle(obj,name) { if(obj.currentStyle){ return obj.currentStyle[name]; } else { return getComputedStyle(obj,false)[name]; } } function startMove(obj,attr,iTarget) { clearInterval(obj.timer); obj.timer=setInterval(function () { var cur=0; if(attr==&quot;opacity&quot;){ cur=Math.round(parseFloat(getStyle(obj,attr))*100); } else { cur=parseInt(getStyle(obj,attr)); } var speed=(iTarget-cur)/6; speed=speed&gt;0?Math.ceil(speed):Math.floor(speed); if(cur==iTarget){ clearInterval(obj.timer); } else{ if(attr==&quot;opacity&quot;){ obj.style.filter=&quot;alpha(opacity:&quot;+(cur+speed)+&quot;&quot;; obj.style.opacity=(cur+speed)/10; document.getElementById(&quot;txt1&quot;).value=obj.style.opacity; } else { obj.style[attr]=cur+speed+&quot;px&quot;; } } },30); }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js悬浮框的实现","date":"2017-03-16T07:50:53.804Z","path":"2017/03/16/js悬浮框的实现/","text":"2016-01-18 23:16:36 星期五 悬浮框随页面滚动而固定于当前页面某一位置实现代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; #div1{ width:150px;height: 200px;background: red;position:absolute;left:-150px;} #div1 span{ position:absolute;width: 20px;height:60px;line-height: 20px;background: blueviolet;right: -20px;top:70px; } &lt;/style&gt; &lt;script&gt; window.onscroll=function () { var oDiv=document.getElementById(&quot;div1&quot;); var scrollTop=document.documentElement.scrollTop||document.body.scrollTop; oDiv.style.top=document.documentElement.clientHeight=oDiv.offsetHeight+scrollTop+&quot;px&quot;; } window.onload=function () { var oDiv=document.getElementById(&quot;div1&quot;); oDiv.onmouseover=function () { startMove(10,0); } oDiv.onmouseout=function () { startMove(-10,-150); } }; var timer=null; function startMove(speed,target) { var oDiv=document.getElementById(&quot;div1&quot;); clearInterval(timer); timer=setInterval(function () { if(oDiv.offsetLeft==target){ clearInterval(timer); } else { oDiv.style.left=oDiv.offsetLeft+speed+&quot;px&quot;; } },30) } &lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;height: 2000px&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;span&gt;分享到&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 1、各浏览器下 scrollTop的差异IE6/7/8：对于没有doctype声明的页面里可以使用 document.body.scrollTop 来获取 scrollTop高度 ；对于有doctype声明的页面则可以使用 document.documentElement.scrollTop；Safari:safari 比较特别，有自己获取scrollTop的函数 ： window.pageYOffset ；Firefox:火狐等等相对标准些的浏览器就省心多了，直接用 document.documentElement.scrollTop ； 2、获取scrollTop值完美的获取scrollTop 赋值短语 ：var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; 通过这句赋值就能在任何情况下获得scrollTop 值。仔细观察这句赋值，你发现啥了没？？没错， 就是 window.pageYOffset (Safari) 被放置在 || 的中间位置。因为当 数字0 与 undefine 进行 或运算时，系统默认返回最后一个值。即或运算中 0 == undefine ;当页面滚动条刚好在最顶端，即scrollTop值为 0 时。 IE 下 window.pageYOffset (Safari) 返回为 undefine ，此时将window.pageYOffset (Safari) 放在或运算最后面时， scrollTop 返回 undefine , undefine 用在接下去的运算就会报错咯。而其他浏览器 无论 scrollTop 赋值或运算顺序如何都不会返回 undefine. 可以安全使用..所以说到头还是IE的问题咯. 杯具…精神有点恍惚，不知道有没有表达清楚。不过最后总结出来这句实验过OK，大家放心使用；var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; DTD相关说明：页面具有 DTD，或者说指定了 DOCTYPE 时，使用 document.documentElement。 页面不具有 DTD，或者说没有指定了 DOCTYPE，时，使用 document.body。 在 IE 和 Firefox 中均是如此。 为了兼容，不管有没有 DTD，可以使用如下代码： var scrollTop = window.pageYOffset //用于FF || document.documentElement.scrollTop || document.body.scrollTop || 0;documentElement 和 body 相关说明： body是DOM对象里的body子节点，即 标签； documentElement 是整个节点树的根节点root，即 标签； DOM把层次中的每一个对象都称之为节点，就是一个层次结构，你可以理解为一个树形结构，就像我们的目录一样，一个根目录，根目录下有子目录，子目录下还有子目录。 以HTML超文本标记语言为例：整个文档的一个根就是,在DOM中可以使用document.documentElement来访问它，它就是整个节点树的根节点。而body是子节点，要访问到body标签，在脚本中应该写：document.body。以HTML超文本标记语言为例：整个文档的一个根就是,在DOM中可以使用document.documentElement来访问它，它就是整个节点树的根节点。而body是子节点，要访问到body标签，在脚本中应该写：document.body。 图片的出现其实就是定时器让图片移出来，到图片全部显示再关闭定时器。移入移出的速度不是有定时器的时间来控制，而是通过每次增加的px的值来控制。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js表单搜索、编辑操作","date":"2017-03-16T07:48:00.288Z","path":"2017/03/16/js表单搜索、编辑操作/","text":"在页面上实现表单数据的添加、搜索等功能一.添加表单内容，隔行变色oTab.tBodies[0].removeChild(this.parentNode.parentNode)1.这里的tBodies相当于document.getElementByTagName(“tbody”)2.removeChild该对象指的是它的子标签，比如tr包着td,那td就是tr的子元素。3.parentNode，同理，获取父级节点。4.昨天的innerHTML就是把某个值设置到该标签里去，看这句就能理解了–&gt; oTd.innerHTML=oAge.value;5.var oID=oTab.tBodies[0].rows.length+1; oTd.innerHTML=oID++;这两句实现了ID不重用（和数据库里的ID一个道理） 下面是表单数据增加，隔行变色的实现代码。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;script&gt; window.onload=function(){ var oTab=document.getElementById(&quot;tab1&quot;); var oBtn=document.getElementById(&quot;btn1&quot;); var oName=document.getElementById(&quot;name&quot;); var oAge=document.getElementById(&quot;age&quot;); var oID=oTab.tBodies[0].rows.length+1; oBtn.onclick=function () { var oTr=document.createElement(&quot;tr&quot;); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=oID++; oTr.appendChild(oTd); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=oName.value; oTr.appendChild(oTd); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=oAge.value; oTr.appendChild(oTd); var oTd=document.createElement(&quot;td&quot;); oTd.innerHTML=&quot;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&quot;; oTd.getElementsByTagName(&quot;a&quot;)[0].onclick=function () { oTab.tBodies[0].removeChild(this.parentNode.parentNode) } oTr.appendChild(oTd); oTab.tBodies[0].appendChild(tr); } var oldColor=&quot;&quot;; for(var i=0;i&lt;oTab.tBodies[0].rows.length;i++){ oTab.tBodies[0].rows[i].onmouseover=function () { oldColor=this.style.background; this.style.background=&quot;red&quot;; } oTab.tBodies[0].rows[i].onmouseout=function () { this.style.background=oldColor; } if(i%2){ oTab.tBodies[0].rows[i].style.background=&quot;#ccc&quot;; } else { oTab.tBodies[0].rows[i].style.background=&quot;&quot;; } } } &lt;/script&gt; &lt;body&gt; 姓名：&lt;input id=&quot;name&quot; type=&quot;text&quot; /&gt; 年龄：&lt;input id=&quot;age&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;添加&quot;/&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;操作&quot;/&gt; &lt;table border=&quot;5px&quot; width=&quot;500px&quot; ID=&quot;tab1&quot;&gt; &lt;thead&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;BLUE&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 二. 搜索：主要是关键字和忽略大小写的两个函数的使用toLowerCase()、search().(oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase()).search(oName.value.toLowerCase())!=-1 完整代码如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;script&gt; window.onload=function(){ var oTab=document.getElementById(&quot;tab1&quot;); var oBtn=document.getElementById(&quot;btn1&quot;); var oName=document.getElementById(&quot;name&quot;); oBtn.onclick=function () { for(var i=0;i&lt;oTab.tBodies[0].rows.length;i++){ if((oTab.tBodies[0].rows[i].cells[1].innerHTML.toLowerCase()).search(oName.value.toLowerCase())!=-1){ oTab.tBodies[0].rows[i].style.background=&quot;yellow&quot;; } else{ oTab.tBodies[0].rows[i].style.background=&quot;&quot;; } } } } &lt;/script&gt; &lt;body&gt; 姓名：&lt;input id=&quot;name&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;btn1&quot; type=&quot;button&quot; value=&quot;搜索&quot;/&gt; &lt;table border=&quot;5px&quot; width=&quot;500px&quot; ID=&quot;tab1&quot;&gt; &lt;thead&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;21&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4&lt;/td&gt; &lt;td&gt;BLUE&lt;/td&gt; &lt;td&gt;15&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 在家学习不静心，学着学着就出去吃东西，哎喂，你说，为什么垃圾食品那么好吃？","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS3 2D3D转换","date":"2017-03-16T07:46:36.788Z","path":"2017/03/16/CSS3 2D3D转换/","text":"一、transform transform: translate(50px,100px);通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数 transform: rotate(30deg);通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 transform: scale(2,4);通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： transform: skew(30deg,20deg);通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数： transform:matrix(0.866,0.5,-0.5,0.866,0,0);matrix() 方法把所有 2D 转换方法组合在一起。matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 二、3D转换transform不仅可以实现2D转换，还可以实现3D转换 2.1 translate移动/沿着X轴的正方向移动45px/transform: translateX(45px);/沿着Y轴的正方向移动45px/transform: translateY(45px);/沿着Z轴的正方向移动45px/transform: translateZ(45px); 2.2 rotate旋转transform: rotate(45deg);// 让元素在平面2D中旋转transform: rotateX(45deg);// 让元素沿着X轴转45度transform: rotateY(45deg);// 让元素沿着Y轴转45度transform: rotateZ(45deg);// 让元素沿着Z轴转45度 2.3 perspective透视电脑显示屏是一个2D的平面，因为我们看不出来旋转的方向，通过perspective属性，可以定义3D 元素距视图的距离，单位是px。说白了，设置了perspective属性后，就有了进大远小的效果了，在视觉上，让我们能看出来3d的效果。注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。perspective：500px;关于近大远小：对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。 2.4坐标系用X、Y、Z分别表示空间的3个维度，三条轴互相垂直。注意+Y是向下的。 2.5transform-styletransform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加。flat:默认值，2d显示preserve-3d: 3d显示 &lt;!--3D导航--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; *{ padding: 0; margin:0; } ul{ list-style: none; width: 800px; height: 40px; border: 1px solid #000; margin:200px auto; } li{ width: 100px; height: 40px; position: relative; transform-style: preserve-3d; transition: all 1s; float:left; } li:hover{ transform: rotateX(-90deg); } span{ width: 100px; height: 40px; display: block; position: absolute; top:0; left:0; line-height: 40px; text-align: center; } span:nth-child(1){ background-color: green; transform: translateZ(20px); } span:nth-child(2){ background-color: red; transform: rotateX(90deg) translateZ(20px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;111&lt;/span&gt; &lt;span&gt;222&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--立方体--&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .box{ width: 200px; height: 200px; border: 1px solid #000; margin: 200px auto; position: relative; transform-style: preserve-3d; transition:all 4s; } .box:hover{ transform:rotateX(360deg) rotateY(360deg); } .m{ width: 100%; height: 100%; position: absolute; top:0; left: 0; font-size: 64px; line-height: 200px; text-align: center; color: black; } .m:nth-child(1){ background-color:red ; transform:translateZ(100px); } .m:nth-child(2){ background-color:yellow ; transform: rotateX(90deg) translateZ(100px); } .m:nth-child(3){ background-color:darkred ; transform: rotateX(180deg) translateZ(100px); } .m:nth-child(4){ background-color:deeppink ; transform: rotateX(270deg) translateZ(100px); } .m:nth-child(5){ background-color:green ; transform: rotateY(90deg) translateZ(100px); } .m:nth-child(6){ background-color:green ; transform: rotateY(270deg) translateZ(100px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;m&quot;&gt;font&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;22&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;33&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;44&lt;/div&gt; &lt;div class=&quot;m&quot;&gt;55&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"js图片滚动和动态时钟的实现","date":"2017-03-16T07:45:27.335Z","path":"2017/03/16/js图片滚动和动态时钟的实现/","text":"2016-01-16 22:59:14 星期三js定时器有以下两个方法： setInterval():按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到clearInterval()被调用或窗口被关闭。 setTimeout():在指定的毫秒数后调用函数或计算表达式。 语法setInterval（code，millisec）setTimeout(code，millisec) 属性 说明 code 必须有。要调用的函数或要执行的代码串 millisec 必须有。周期性执行或调用code之间的时间间隔，以毫秒计 &lt;script type=&quot;text/javascript&quot;&gt; //在网页上输出：今天的日期、星期、现在的时间（动态时钟） function start() { var today=new Date(); var year=today.getFullYear(); var month=today.getMonth()+1; var day=today.getDate(); var hours=today.getHours(); var minutes=today.getMinutes(); var seconds=today.getSeconds(); //如果是单位数字，前面补0 month=month&lt;10? &quot;0&quot;+month :month; day=day&lt;10? &quot;0&quot;+day :day; hours=hours&lt;10? &quot;0&quot;+hours :hours; minutes=minutes&lt;10? &quot;0&quot;+minutes :minutes; seconds=seconds&lt;10? &quot;0&quot;+seconds :seconds; //时间信息连成字符串 var str=&quot;今天是&quot;+year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日 &quot;+hours+&quot;:&quot;+minutes+&quot;:&quot;+seconds; //获取id=result的内容 var obj=document.getElementById(&quot;result&quot;); obj.innerHTML=str; //延时器 window.setTimeout(&quot;start()&quot;,1000); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;start()&quot;&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;/body&gt; 几个对象属性innerHTML:设置或获取位于对象起始和结束标签内的HTMLscrollHeight:获取对象的滚动高度。scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离scrollWidth:获取对象的滚动宽度offsetHeight:获取对象相对于版面或由父坐标offsetParent属性指定的父坐标的高度。 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;title&gt;图片滚动&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;!-- #demo { background: #FFF; overflow:hidden; border: 1px dashed #CCC; width: 500px; } #demo img { border: 3px solid #F2F2F2; } #indemo { float: left; width: 800%; } #demo1 { float: left; } #demo2 { float: left; } --&gt; &lt;/style&gt; &lt;div id=&quot;demo&quot;&gt; &lt;div id=&quot;indemo&quot;&gt; &lt;div id=&quot;demo1&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; border=&quot;0&quot; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;div id=&quot;demo2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; &lt;!-- var speed=10; var tab=document.getElementById(&quot;demo&quot;); var tab1=document.getElementById(&quot;demo1&quot;); var tab2=document.getElementById(&quot;demo2&quot;); tab2.innerHTML=tab1.innerHTML; function Marquee(){ if(tab2.offsetWidth-tab.scrollLeft&lt;=0) tab.scrollLeft-=tab1.offsetWidth else{ tab.scrollLeft++; } } var MyMar=setInterval(Marquee,speed); tab.onmouseover=function() {clearInterval(MyMar)}; tab.onmouseout=function() {MyMar=setInterval(Marquee,speed)}; --&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"复习JS语法","date":"2017-03-16T07:41:57.285Z","path":"2017/03/16/复习JS语法/","text":"js复习2017-03-02 19:24:15 星期四 数值类型&lt;script&gt; var a=3,b=&quot;4&quot;; alert(a+(b-0)); &lt;/script&gt; 不定参 function sum() { //alert(arguments.length) var result=0; for(var i=0;i&lt;arguments.length;i++){ result+=arguments[i]; } alert(result); } sum(11,22,33); css函数 //css(oDiv,’width’)获取样式 //css(oDiv,&apos;width&apos;，&apos;300px&apos;)设置样式 function css() { if(arguments.length==2){ return arguments[0].style[arguments[1]]; } else { arguments[0].style[arguments[1]]=arguments[2]; } } // 与上面等价，简化写法 function css(obj,name,value) { alert(obj=arguments[0]); if(arguments.length==2) { return obj.style[name]=value; } else { obj.style[name]=value; } } window.onload=function () { var oDiv=document.getElementById(&apos;div1&apos;); alert(css(oDiv,&apos;height&apos;)); css(oDiv,&apos;background&apos;,&apos;pink&apos;); css(oDiv,&apos;background&apos;,&apos;red&apos;); } - CSS样式的优先级标签： 1、相同权值情况下，CSS样式的优先级总结来说，就是——就近原则（离被设置元素越近优先级别越高）： 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 2、权值不同时，浏览器是根据权值来判断使用哪种css样式的，哪种样式权值高就使用哪种样式。 下面是权值的规则： 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码： p{color:red;} /标签，权值为1/ p span{color:green;} /两个标签，权值为1+1=2/ p&gt;span{color:purple;}/权值与上面的相同，因此采取就近原则/ .warning{color:white;} /类选择符，权值为10/ p span.warning{color:purple;} /权值为1+1+10=12/ footer .note p{color:yellow;} /权值为100+10+1=111/ 注意：（1）还有一个权值比较特殊——继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。（继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。如便签内部的标签就会继承该标签的样式）； （2）做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，可以使用!important来解决。如下代码：p{color:red!important; /*!important要写在分号前}这里注意当网页制作者不设置css样式时，浏览器会按照自己的一套样式来显示网页。并且用户也可以在浏览器中设置自己习惯的样式，比如有的用户习惯把字号设置为大一些，使其查看网页的文本更加清楚。这时注意样式优先级为：浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但记住!important优先级样式是个例外，权值高于用户自己设置的样式。 3、使用JS对样式进行操作时往往可通过两种方式：object.style.property=new style和object.className = new classname。前者是修改行间样式，JS代码执行后，审查元素可看到样式会直接显示在行间代码中，如：技术分享；后者则是在行间增加了新的class，而不会将具体的样式代码显示出来。 获取非行间样式 if(oDiv.currentStyle){ alert(oDiv.currentStyle.width); } else { alert(getComputedStyle(oDiv,true).width); } 数组操作var arr=[1,2,3,4,5,6]; // arr.push(0);从数组的尾部的添加 //arr.pop();从数组尾部开始删除 //arr.shift();从头部开始删除 //arr.unshift(8);从头部开始添加 //从中间任意位置删除，插入，替换 splice(起点，长度) //arr.splice(2,3); //arr.splice(2,0,&apos;a&apos;,&apos;s&apos;,&apos;d&apos;); arr.splice(2,2,&apos;x&apos;,&apos;y&apos;);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]